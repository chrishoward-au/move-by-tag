/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./main.ts":
/*!*****************!*\
  !*** ./main.ts ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MoveByTag)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n\nconst DEFAULT_SETTINGS = {\n    tagMappings: [],\n    confirmBeforeMove: true,\n    excludedFolders: [],\n    limitedFolders: [],\n    enableLogging: true\n};\nclass MoveByTag extends Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {\n    log(message) {\n        if (this.settings.enableLogging) {\n            console.log(`[Move by Tag] ${message}`);\n        }\n    }\n    generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    onload() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            yield this.loadSettings();\n            // This adds a command to the app's command palette.\n            this.addCommand({\n                id: 'move-by-tag',\n                name: 'Move by Tag',\n                callback: () => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n                    const modal = new MoveByTagModal(this.app, this);\n                    modal.onClose = () => {\n                        // Clean up suggestions when modal is closed\n                        const suggestionsContainer = document.getElementById('folder-suggestions');\n                        if (suggestionsContainer) {\n                            suggestionsContainer.remove();\n                        }\n                    };\n                    modal.open();\n                }),\n            });\n            // Register the command in Obsidian\n            this.addCommand({\n                id: 'show-file-info',\n                name: 'Show File Info',\n                checkCallback: (checking) => {\n                    const activeFile = this.app.workspace.getActiveFile();\n                    if (activeFile) {\n                        if (!checking) {\n                            this.showFileInfo(activeFile);\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            this.addSettingTab(new MoveByTagSettingTab(this.app, this));\n            console.log('Move by Tag Plugin loaded');\n        });\n    }\n    onunload() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            console.log('Move by Tag Plugin unloaded');\n            // Reset settings to default\n            // this.settings = Object.assign({}, DEFAULT_SETTINGS);\n            // await this.saveData({}); // Clear all stored data\n        });\n    }\n    extractTags(content) {\n        const tagRegex = /#\\w+/g;\n        return content.match(tagRegex) || [];\n    }\n    showFileInfo(file) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            const content = yield this.app.vault.read(file);\n            this.showFileInfoDialog(file.path, content);\n        });\n    }\n    showFileInfoDialog(filePath, content) {\n        const fileName = filePath.split('/').pop();\n        const tags = this.extractTags(content);\n        const dialogContent = `File Name: ${fileName}\\nLocation: ${filePath}\\nTags: ${tags.join(', ')}`;\n        const dialog = new InfoDialog(this.app, dialogContent);\n        dialog.open();\n    }\n    loadSettings() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            const loadedData = yield this.loadData();\n            console.log('Loaded settings data:', loadedData);\n            // Check if tagMappings is an object (old format)\n            if (loadedData.tagMappings && typeof loadedData.tagMappings === 'object' && !Array.isArray(loadedData.tagMappings)) {\n                // Convert old format to new format\n                const oldMappings = loadedData.tagMappings;\n                const convertedMappings = [];\n                // Group mappings by folder\n                const folderToTags = {};\n                Object.entries(oldMappings).forEach(([tag, folder]) => {\n                    if (!folderToTags[folder]) {\n                        folderToTags[folder] = [];\n                    }\n                    folderToTags[folder].push(tag);\n                });\n                // Create new mappings\n                Object.entries(folderToTags).forEach(([folder, tags]) => {\n                    convertedMappings.push({\n                        tags: tags,\n                        folder: folder,\n                        id: this.generateId()\n                    });\n                });\n                this.settings.tagMappings = convertedMappings;\n            }\n            else {\n                // If not in old format, assign directly\n                this.settings.tagMappings = loadedData.tagMappings || [];\n            }\n            console.log('Loaded excluded folders:', loadedData.excludedFolders);\n            console.log('Loaded limited folders:', loadedData.limitedFolders);\n            // Merge with default settings\n            this.settings = Object.assign(Object.assign({}, DEFAULT_SETTINGS), this.settings);\n        });\n    }\n    saveSettings() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            console.log('Saving settings data:', this.settings);\n            yield this.saveData(this.settings);\n        });\n    }\n}\nclass MoveByTagModal extends Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {\n    constructor(app, plugin) {\n        super(app);\n        this.settings = plugin.settings;\n        this.plugin = plugin;\n    }\n    showConfirmationDialog(movements) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            return new Promise((resolve) => {\n                const modal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.app);\n                modal.contentEl.createEl('h2', { text: 'Confirm File Movements' });\n                const container = modal.contentEl.createEl('div', { cls: 'move-by-tag-confirmation' });\n                container.createEl('p', { text: `About to move ${movements.length} files:` });\n                const list = container.createEl('ul');\n                movements.slice(0, 10).forEach(({ file, targetPath }) => {\n                    list.createEl('li', { text: `${file.path} → ${targetPath}` });\n                });\n                if (movements.length > 10) {\n                    container.createEl('p', { text: `...and ${movements.length - 10} more files` });\n                }\n                const buttonContainer = container.createEl('div', { cls: 'move-by-tag-buttons' });\n                buttonContainer.createEl('button', { text: 'Cancel' })\n                    .addEventListener('click', () => {\n                    modal.close();\n                    resolve(false);\n                });\n                buttonContainer.createEl('button', { text: 'Confirm' })\n                    .addEventListener('click', () => {\n                    modal.close();\n                    resolve(true);\n                });\n                modal.onClose = () => {\n                    // Clean up suggestions when modal is closed\n                    const suggestionsContainer = document.getElementById('folder-suggestions');\n                    if (suggestionsContainer) {\n                        suggestionsContainer.remove();\n                    }\n                };\n                modal.open();\n            });\n        });\n    }\n    onOpen() {\n        const { contentEl } = this;\n        contentEl.setText('Move files based on their tags');\n        this.plugin.log('Opening Move by Tag modal');\n        // Add a button to trigger the file movement process\n        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n            .addButton((btn) => btn\n            .setButtonText('Move Files')\n            .onClick(() => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            yield this.moveFilesByTag();\n        })));\n    }\n    moveFilesByTag() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            const { vault } = this.app;\n            try {\n                this.plugin.log('Starting file movement process...');\n                const files = this.app.vault.getMarkdownFiles().filter(file => {\n                    return this.settings.limitedFolders.length === 0 ||\n                        this.settings.limitedFolders.some(folder => file.path.startsWith(folder));\n                });\n                this.plugin.log(`Found ${files.length} markdown files total`);\n                const movements = [];\n                // First, plan all movements\n                for (const file of files) {\n                    this.plugin.log(`Processing file: ${file.path}`);\n                    // Normalize file path\n                    const normalizedFilePath = file.path.startsWith('/') ? file.path : '/' + file.path;\n                    // Skip files in excluded folders\n                    if (this.settings.excludedFolders.some(folder => {\n                        const normalizedFolder = folder.startsWith('/') ? folder : '/' + folder;\n                        return normalizedFilePath.startsWith(normalizedFolder);\n                    })) {\n                        this.plugin.log(`Skipping excluded file: ${file.path}`);\n                        continue;\n                    }\n                    const tags = yield this.extractTags(file);\n                    this.plugin.log(`Found tags in ${file.path}: ${tags.join(', ') || 'none'}`);\n                    if (tags.length > 0) {\n                        const matches = this.getTargetFolderForTags(tags);\n                        if (matches.length > 0) {\n                            let targetFolder = matches[0].mapping.folder;\n                            // If there are multiple matches, show dialog for user to choose\n                            if (matches.length > 1) {\n                                this.plugin.log(`Found multiple matching folders for ${file.path}: ${matches.map(m => m.mapping.folder).join(', ')}`);\n                                targetFolder = yield this.showRuleConflictDialog(file, matches);\n                                if (!targetFolder) {\n                                    this.plugin.log(`User skipped file ${file.path} due to rule conflict`);\n                                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(`Skipped ${file.name} due to rule conflict`);\n                                    continue;\n                                }\n                            }\n                            this.plugin.log(`Selected target folder: ${targetFolder}`);\n                            const targetPath = `${targetFolder}/${file.name}`;\n                            // Check if file already exists in target\n                            if (yield this.app.vault.adapter.exists(targetPath)) {\n                                this.plugin.log(`File already exists at target location: ${targetPath}`);\n                                new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(`Skipping ${file.name}: File already exists in target location`);\n                                continue;\n                            }\n                            this.plugin.log(`Planning to move ${file.path} to ${targetPath}`);\n                            movements.push({ file, targetPath });\n                        }\n                        else {\n                            this.plugin.log(`No matching folder found for tags: ${tags.join(', ')}`);\n                        }\n                    }\n                    else {\n                        this.plugin.log(`No tags found in file: ${file.path}`);\n                    }\n                }\n                // If no files to move, notify and close\n                if (movements.length === 0) {\n                    this.plugin.log('No files to move - no valid tag mappings found');\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('No files to move');\n                    this.close();\n                    return;\n                }\n                this.plugin.log(`Found ${movements.length} files to move`);\n                // Show confirmation if enabled\n                if (this.settings.confirmBeforeMove) {\n                    const confirmed = yield this.showConfirmationDialog(movements);\n                    if (!confirmed) {\n                        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('Operation cancelled');\n                        return;\n                    }\n                }\n                // Perform movements\n                let successCount = 0;\n                for (const { file, targetPath } of movements) {\n                    try {\n                        yield this.app.vault.rename(file, targetPath);\n                        successCount++;\n                        if (this.settings.enableLogging) {\n                            console.log(`Moved ${file.path} to ${targetPath}`);\n                        }\n                    }\n                    catch (error) {\n                        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(`Failed to move ${file.name}: ${error.message}`);\n                    }\n                }\n                new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(`Successfully moved ${successCount} of ${movements.length} files`);\n                this.close();\n            }\n            catch (error) {\n                new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(`Error during file movement: ${error.message}`);\n                console.error('Move by Tag error:', error);\n                this.close();\n            }\n        });\n    }\n    extractTags(file) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            try {\n                this.plugin.log(`Reading content from file: ${file.path}`);\n                const content = yield this.app.vault.read(file);\n                const tagRegex = /#([\\w-]+)/g;\n                const tags = [];\n                let match;\n                while ((match = tagRegex.exec(content)) !== null) {\n                    tags.push(match[1]);\n                }\n                this.plugin.log(`Extracted tags from ${file.path}: ${tags.join(', ') || 'none'}`);\n                return tags;\n            }\n            catch (error) {\n                this.plugin.log(`Error extracting tags from ${file.path}: ${error.message}`);\n                return [];\n            }\n        });\n    }\n    getTargetFolderForTags(fileTags) {\n        if (this.settings.tagMappings.length === 0) {\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('No mappings defined.');\n            return [];\n        }\n        this.plugin.log(`Checking tag mappings for tags: ${fileTags.join(', ')}`);\n        this.plugin.log(`Available mappings: ${JSON.stringify(this.settings.tagMappings)}`);\n        // Convert file tags to lowercase for case-insensitive matching\n        const lowerFileTags = fileTags.map(tag => tag.toLowerCase());\n        const matches = [];\n        // Check each mapping\n        for (const mapping of this.settings.tagMappings) {\n            // Convert mapping tags to lowercase\n            const lowerMappingTags = mapping.tags.map(tag => tag.toLowerCase());\n            // Track which tags from the mapping were found in the file\n            const matchedTags = [];\n            // Check each tag in the mapping\n            for (const mappingTag of mapping.tags) {\n                const lowerMappingTag = mappingTag.toLowerCase();\n                // Check if any file tag matches this mapping tag\n                const matchingFileTag = lowerFileTags.find(fileTag => fileTag === lowerMappingTag ||\n                    fileTag === lowerMappingTag + 's' ||\n                    fileTag.slice(0, -1) === lowerMappingTag);\n                if (matchingFileTag) {\n                    matchedTags.push(mappingTag);\n                }\n            }\n            // If all tags in the mapping were found, it's a match\n            if (matchedTags.length === mapping.tags.length) {\n                this.plugin.log(`Found matching mapping: ${mapping.tags.join(' + ')} → ${mapping.folder}`);\n                matches.push({ mapping, matchedTags });\n            }\n        }\n        if (matches.length === 0) {\n            this.plugin.log('No matching folder found for tags');\n        }\n        return matches;\n    }\n    showRuleConflictDialog(file, matches) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            return new Promise((resolve) => {\n                const modal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.app);\n                modal.titleEl.setText(`\"${file.name}\"`);\n                const container = modal.contentEl.createEl('div');\n                container.createEl('p', {\n                    text: `This file matches multiple tag rules. Please select which folder to move it to:`\n                });\n                const list = container.createEl('div');\n                matches.forEach(({ mapping, matchedTags }) => {\n                    const row = list.createEl('div', { cls: 'move-by-tag-rule-option' });\n                    const button = row.createEl('button', {\n                        text: `Move to ${mapping.folder} (tags: ${mapping.tags.map(t => '#' + t).join(' + ')})`,\n                        cls: 'mod-cta'\n                    });\n                    button.style.marginBottom = '10px'; // Add margin to the bottom of the button\n                    button.addEventListener('click', () => {\n                        modal.close();\n                        resolve(mapping.folder);\n                    });\n                });\n                // Add cancel button\n                const cancelButton = container.createEl('button', {\n                    text: 'Skip this file',\n                    cls: 'move-by-tag-cancel'\n                });\n                cancelButton.addEventListener('click', () => {\n                    modal.close();\n                    resolve(null);\n                });\n                modal.onClose = () => {\n                    // Clean up suggestions when modal is closed\n                    const suggestionsContainer = document.getElementById('folder-suggestions');\n                    if (suggestionsContainer) {\n                        suggestionsContainer.remove();\n                    }\n                };\n                modal.open();\n            });\n        });\n    }\n}\nclass InfoDialog extends Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {\n    constructor(app, content) {\n        super(app);\n        this.content = content;\n    }\n    onOpen() {\n        const { contentEl } = this;\n        contentEl.setText(this.content);\n    }\n    onClose() {\n        const { contentEl } = this;\n        contentEl.empty();\n    }\n}\nclass MoveByTagSettingTab extends Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {\n    constructor(app, plugin) {\n        super(app, plugin);\n        this.plugin = plugin;\n    }\n    display() {\n        const { containerEl } = this;\n        containerEl.empty();\n        // General Settings Section\n        containerEl.createEl('h3', { text: 'General Settings' });\n        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(containerEl)\n            .setName('Confirm Before Moving')\n            .setDesc('Show confirmation dialog before moving files')\n            .addToggle(toggle => toggle\n            .setValue(this.plugin.settings.confirmBeforeMove)\n            .onChange((value) => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            this.plugin.settings.confirmBeforeMove = value;\n            yield this.plugin.saveSettings();\n        })));\n        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(containerEl)\n            .setName('Enable Logging')\n            .setDesc('Log file movements to console')\n            .addToggle(toggle => toggle\n            .setValue(this.plugin.settings.enableLogging)\n            .onChange((value) => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            this.plugin.settings.enableLogging = value;\n            yield this.plugin.saveSettings();\n        })));\n        // Excluded Folders Section\n        containerEl.createEl('h3', { text: 'Excluded Folders' });\n        containerEl.createEl('p', {\n            text: 'Files in these folders will not be moved. One folder path per line.',\n            cls: 'setting-item-description'\n        });\n        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(containerEl)\n            .addTextArea(text => {\n            // Set initial value from settings\n            const excludedFolders = this.plugin.settings.excludedFolders || [];\n            text.setValue(excludedFolders.join('\\n'))\n                .setPlaceholder('folder1/subfolder\\nfolder2')\n                .onChange((value) => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n                this.plugin.settings.excludedFolders = value.split('\\n')\n                    .map(f => f.trim())\n                    .filter(f => f.length > 0);\n                yield this.plugin.saveSettings();\n            }));\n        });\n        // Specific Folders Section\n        containerEl.createEl('h3', { text: 'Specific Folders' });\n        containerEl.createEl('p', {\n            text: 'Files will only be moved from these folders. One folder path per line.',\n            cls: 'setting-item-description'\n        });\n        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(containerEl)\n            .addTextArea(text => {\n            // Set initial value from settings\n            const limitedFolders = this.plugin.settings.limitedFolders || [];\n            text.setValue(limitedFolders.join('\\n'))\n                .setPlaceholder('folder1/subfolder\\nfolder2')\n                .onChange((value) => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n                this.plugin.settings.limitedFolders = value.split('\\n')\n                    .map(f => f.trim())\n                    .filter(f => f.length > 0);\n                yield this.plugin.saveSettings();\n            }));\n        });\n        // Tag Mappings Section\n        containerEl.createEl('h3', { text: 'Tag Mappings' });\n        containerEl.createEl('p', {\n            text: 'Define where files should be moved based on their tags.',\n            cls: 'setting-item-description'\n        });\n        // Add New Mapping and Delete All Buttons at the top\n        new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(containerEl)\n            .addButton(button => button\n            .setButtonText('Add New Mapping')\n            .setCta() // Make it stand out as the primary action\n            .onClick(() => this.showNewMappingModal()));\n        // Existing Mappings\n        const mappingsContainer = containerEl.createDiv('tag-mappings-container');\n        if (this.plugin.settings.tagMappings.length === 0) {\n            mappingsContainer.createEl('p', {\n                text: 'No tag mappings defined yet. Click \"Add New Mapping\" to create one.',\n                cls: 'setting-item-description'\n            });\n        }\n        // Sort mappings by first tag\n        const sortedMappings = [...this.plugin.settings.tagMappings]\n            .sort((a, b) => a.tags[0].localeCompare(b.tags[0]));\n        for (const mapping of sortedMappings) {\n            const tagDisplay = mapping.tags.map(t => '#' + t).join(' + ');\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(mappingsContainer)\n                .setName(tagDisplay)\n                .setDesc(`Current destination: ${mapping.folder}`)\n                .addButton(button => button\n                .setButtonText('Edit')\n                .onClick(() => {\n                this.showEditMappingModal(mapping);\n            }));\n            // .addButton(button => button\n            //   .setIcon('trash')\n            //   .setTooltip('Delete mapping')\n            //   .onClick(async () => {\n            //     if (await this.showDeleteConfirmation(mapping)) {\n            //       this.plugin.settings.tagMappings = this.plugin.settings.tagMappings\n            //         .filter(m => m.id !== mapping.id);\n            //       await this.plugin.saveSettings();\n            //       this.display();\n            //     }\n            //   }));\n        }\n        ;\n    }\n    generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    showNewMappingModal() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            const modal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.app);\n            modal.titleEl.setText('Create New Tag Mapping');\n            const contentEl = modal.contentEl;\n            let tagsInput;\n            // Tags input\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                .setName('Tags')\n                .setDesc('Enter tags without # symbol, separated by commas. All tags must be present for the rule to apply.')\n                .addText(text => {\n                tagsInput = text;\n                text.setPlaceholder('tag1, tag2, tag3');\n            });\n            // Folder input\n            const folderSetting = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                .setName('Destination Folder')\n                .addText((text) => {\n                this.folderInput = text;\n                text.setPlaceholder('folder/subfolder');\n                text.inputEl.style.width = '300px'; // Make input field wider\n                text.onChange((value) => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n                    const results = yield this.searchFolders(value);\n                    this.displayFolderSuggestions(results);\n                }));\n            });\n            // Buttons\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                .addButton(button => button\n                .setButtonText('Cancel')\n                .onClick(() => modal.close()))\n                .addButton(button => button\n                .setButtonText('Add')\n                .setCta()\n                .onClick(() => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n                const tagsValue = tagsInput.getValue().trim();\n                const folder = this.folderInput.getValue().trim();\n                if (!tagsValue || !folder) {\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('Both tags and folder are required');\n                    return;\n                }\n                const tags = tagsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n                if (tags.length === 0) {\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('At least one tag is required');\n                    return;\n                }\n                // Check for duplicate tag combinations\n                const tagSet = new Set(tags.map(t => t.toLowerCase()));\n                if (this.plugin.settings.tagMappings.some(m => m.tags.length === tags.length &&\n                    m.tags.every(t => tagSet.has(t.toLowerCase())))) {\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('This tag combination already has a mapping');\n                    return;\n                }\n                const newMapping = {\n                    id: this.generateId(),\n                    tags,\n                    folder\n                };\n                this.plugin.settings.tagMappings.push(newMapping);\n                yield this.plugin.saveSettings();\n                this.display();\n                modal.close();\n            })));\n            modal.onClose = () => {\n                // Clean up suggestions when modal is closed\n                const suggestionsContainer = document.getElementById('folder-suggestions');\n                if (suggestionsContainer) {\n                    suggestionsContainer.remove();\n                }\n            };\n            modal.open();\n        });\n    }\n    searchFolders(query) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            if (!query)\n                return [];\n            const folders = this.app.vault.getAllFolders();\n            console.log('All folders:', folders);\n            let folderPaths = folders.map(folder => {\n                // Ensure leading slash for root-level folders\n                return folder.path === '/' ? '/' : (folder.path.startsWith('/') ? folder.path : '/' + folder.path);\n            });\n            // If limited folders are set, only show folders within those paths\n            if (this.plugin.settings.limitedFolders.length > 0) {\n                const normalizedLimitedFolders = this.plugin.settings.limitedFolders.map(folder => folder.startsWith('/') ? folder : '/' + folder);\n                folderPaths = folderPaths.filter(path => normalizedLimitedFolders.some(limitedFolder => path.startsWith(limitedFolder) || limitedFolder.startsWith(path)));\n            }\n            // Apply search query filter\n            folderPaths = folderPaths\n                .filter(path => path.toLowerCase().includes(query.toLowerCase()))\n                .sort();\n            return folderPaths;\n        });\n    }\n    displayFolderSuggestions(folders) {\n        // Clear previous suggestions\n        const suggestionsContainer = document.getElementById('folder-suggestions');\n        if (suggestionsContainer) {\n            suggestionsContainer.remove();\n        }\n        // Create a new suggestions container\n        const newContainer = document.createElement('div');\n        newContainer.id = 'folder-suggestions';\n        newContainer.style.position = 'absolute';\n        newContainer.style.backgroundColor = 'white';\n        newContainer.style.border = '1px solid #ccc';\n        newContainer.style.zIndex = '1000';\n        // Add suggestions to the container\n        folders.forEach(folder => {\n            const suggestionItem = document.createElement('div');\n            suggestionItem.textContent = folder;\n            suggestionItem.style.padding = '5px';\n            suggestionItem.style.cursor = 'pointer';\n            // Add click event to select folder\n            suggestionItem.addEventListener('click', () => {\n                this.folderInput.setValue(folder); // Set the input value to the selected folder\n                newContainer.remove(); // Remove suggestions after selection\n            });\n            newContainer.appendChild(suggestionItem);\n        });\n        // Position the suggestions container under the input field\n        const inputEl = this.folderInput.inputEl;\n        const rect = inputEl.getBoundingClientRect();\n        const modalEl = document.querySelector('.modal');\n        const modalWidth = modalEl ? modalEl.getBoundingClientRect().width : 500;\n        newContainer.style.position = 'absolute';\n        newContainer.style.left = `${rect.left}px`;\n        newContainer.style.top = `${rect.bottom}px`;\n        newContainer.style.width = `${Math.min(modalWidth - 40, 300)}px`; // Use modal width minus padding, max 500px\n        newContainer.style.maxHeight = '200px';\n        newContainer.style.overflowY = 'auto';\n        newContainer.style.overflowX = 'hidden';\n        newContainer.style.textOverflow = 'ellipsis';\n        newContainer.style.whiteSpace = 'nowrap';\n        // Append the suggestions container\n        document.body.appendChild(newContainer);\n    }\n    showEditMappingModal(mapping) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            const modal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.app);\n            modal.titleEl.setText('Edit Tag Mapping');\n            const contentEl = modal.contentEl;\n            let tagsInput;\n            // Tags input\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                .setName('Tags')\n                .setDesc('Enter tags without # symbol, separated by commas. All tags must be present for the rule to apply.')\n                .addText(text => {\n                tagsInput = text;\n                text.setPlaceholder('tag1, tag2, tag3')\n                    .setValue(mapping.tags.join(', '));\n            });\n            // Folder input\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                .setName('Destination Folder')\n                .addText((text) => {\n                this.folderInput = text;\n                text.setPlaceholder('folder/subfolder')\n                    .setValue(mapping.folder);\n            });\n            // Buttons\n            new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                .addButton(button => button\n                .setButtonText('Cancel')\n                .onClick(() => modal.close()))\n                .addButton(button => button\n                .setButtonText('Save')\n                .setCta()\n                .onClick(() => (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n                const tagsValue = tagsInput.getValue().trim();\n                const folder = this.folderInput.getValue().trim();\n                if (!tagsValue || !folder) {\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('Both tags and folder are required');\n                    return;\n                }\n                const tags = tagsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n                if (tags.length === 0) {\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('At least one tag is required');\n                    return;\n                }\n                // Check for duplicate tag combinations, excluding the current mapping\n                const tagSet = new Set(tags.map(t => t.toLowerCase()));\n                if (this.plugin.settings.tagMappings.some(m => m.id !== mapping.id && // Exclude current mapping\n                    m.tags.length === tags.length &&\n                    m.tags.every(t => tagSet.has(t.toLowerCase())))) {\n                    new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('This tag combination already has a mapping');\n                    return;\n                }\n                // Update the existing mapping\n                mapping.tags = tags;\n                mapping.folder = folder;\n                yield this.plugin.saveSettings();\n                this.display();\n                modal.close();\n            })));\n            modal.onClose = () => {\n                // Clean up suggestions when modal is closed\n                const suggestionsContainer = document.getElementById('folder-suggestions');\n                if (suggestionsContainer) {\n                    suggestionsContainer.remove();\n                }\n            };\n            modal.open();\n        });\n    }\n    showDeleteAllConfirmation() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            return new Promise((resolve) => {\n                const modal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.app);\n                modal.titleEl.setText('Delete All Tag Mappings');\n                const contentEl = modal.contentEl;\n                contentEl.createEl('p', {\n                    text: 'Are you sure you want to delete all tag mappings? This action cannot be undone.'\n                });\n                new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                    .addButton(button => button\n                    .setButtonText('Cancel')\n                    .onClick(() => {\n                    modal.close();\n                    resolve(false);\n                }))\n                    .addButton(button => button\n                    .setButtonText('Delete All')\n                    .setWarning()\n                    .onClick(() => {\n                    modal.close();\n                    resolve(true);\n                }));\n                modal.onClose = () => {\n                    // Clean up suggestions when modal is closed\n                    const suggestionsContainer = document.getElementById('folder-suggestions');\n                    if (suggestionsContainer) {\n                        suggestionsContainer.remove();\n                    }\n                };\n                modal.open();\n            });\n        });\n    }\n    showDeleteConfirmation(mapping) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {\n            return new Promise((resolve) => {\n                const modal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.app);\n                modal.titleEl.setText('Delete Tag Mapping');\n                const contentEl = modal.contentEl;\n                const tagDisplay = mapping.tags.map(t => '#' + t).join(' + ');\n                contentEl.createEl('p', {\n                    text: `Are you sure you want to delete the mapping for ${tagDisplay}?\\n` +\n                        `Files with these tags will no longer be moved automatically.`\n                });\n                new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'obsidian'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(contentEl)\n                    .addButton(button => button\n                    .setButtonText('Cancel')\n                    .onClick(() => {\n                    modal.close();\n                    resolve(false);\n                }))\n                    .addButton(button => button\n                    .setButtonText('Delete')\n                    .setWarning()\n                    .onClick(() => {\n                    modal.close();\n                    resolve(true);\n                }));\n                modal.onClose = () => {\n                    // Clean up suggestions when modal is closed\n                    const suggestionsContainer = document.getElementById('folder-suggestions');\n                    if (suggestionsContainer) {\n                        suggestionsContainer.remove();\n                    }\n                };\n                modal.open();\n            });\n        });\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFnQixPQUFPLEVBQUUsTUFBTSxFQUFTLGdCQUFnQixFQUFpQixNQUFNLFVBQVUsQ0FBQztBQWdCaEgsTUFBTSxnQkFBZ0IsR0FBc0I7SUFDMUMsV0FBVyxFQUFFLEVBQUU7SUFDZixpQkFBaUIsRUFBRSxJQUFJO0lBQ3ZCLGVBQWUsRUFBRSxFQUFFO0lBQ25CLGNBQWMsRUFBRSxFQUFFO0lBQ2xCLGFBQWEsRUFBRSxJQUFJO0NBQ3BCLENBQUM7QUFFRixNQUFNLENBQUMsT0FBTyxPQUFPLFNBQVUsU0FBUSxNQUFNO0lBR3BDLEdBQUcsQ0FBQyxPQUFlO1FBQ3hCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQzFDLENBQUM7SUFDSCxDQUFDO0lBRU8sVUFBVTtRQUNoQixPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVLLE1BQU07O1lBQ1YsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFMUIsb0RBQW9EO1lBQ3BELElBQUksQ0FBQyxVQUFVLENBQUM7Z0JBQ2QsRUFBRSxFQUFFLGFBQWE7Z0JBQ2pCLElBQUksRUFBRSxhQUFhO2dCQUNuQixRQUFRLEVBQUUsR0FBUyxFQUFFO29CQUNuQixNQUFNLEtBQUssR0FBRyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUNqRCxLQUFLLENBQUMs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bmcsIE5vdGljZSwgVEZpbGUsIFBsdWdpblNldHRpbmdUYWIsIFRleHRDb21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5cbmludGVyZmFjZSBUYWdNYXBwaW5nIHtcbiAgdGFnczogc3RyaW5nW107XG4gIGZvbGRlcjogc3RyaW5nO1xuICBpZDogc3RyaW5nOyAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIG1hcHBpbmdcbn1cblxuaW50ZXJmYWNlIE1vdmVCeVRhZ1NldHRpbmdzIHtcbiAgdGFnTWFwcGluZ3M6IFRhZ01hcHBpbmdbXTtcbiAgY29uZmlybUJlZm9yZU1vdmU6IGJvb2xlYW47XG4gIGV4Y2x1ZGVkRm9sZGVyczogc3RyaW5nW107XG4gIGxpbWl0ZWRGb2xkZXJzOiBzdHJpbmdbXTtcbiAgZW5hYmxlTG9nZ2luZzogYm9vbGVhbjtcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogTW92ZUJ5VGFnU2V0dGluZ3MgPSB7XG4gIHRhZ01hcHBpbmdzOiBbXSxcbiAgY29uZmlybUJlZm9yZU1vdmU6IHRydWUsXG4gIGV4Y2x1ZGVkRm9sZGVyczogW10sXG4gIGxpbWl0ZWRGb2xkZXJzOiBbXSxcbiAgZW5hYmxlTG9nZ2luZzogdHJ1ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92ZUJ5VGFnIGV4dGVuZHMgUGx1Z2luIHtcbiAgc2V0dGluZ3M6IE1vdmVCeVRhZ1NldHRpbmdzO1xuXG4gIHB1YmxpYyBsb2cobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTG9nZ2luZykge1xuICAgICAgY29uc29sZS5sb2coYFtNb3ZlIGJ5IFRhZ10gJHttZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgLy8gVGhpcyBhZGRzIGEgY29tbWFuZCB0byB0aGUgYXBwJ3MgY29tbWFuZCBwYWxldHRlLlxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ21vdmUtYnktdGFnJyxcbiAgICAgIG5hbWU6ICdNb3ZlIGJ5IFRhZycsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBNb3ZlQnlUYWdNb2RhbCh0aGlzLmFwcCwgdGhpcyk7XG4gICAgICAgIG1vZGFsLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cCBzdWdnZXN0aW9ucyB3aGVuIG1vZGFsIGlzIGNsb3NlZFxuICAgICAgY29uc3Qgc3VnZ2VzdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9sZGVyLXN1Z2dlc3Rpb25zJyk7XG4gICAgICBpZiAoc3VnZ2VzdGlvbnNDb250YWluZXIpIHtcbiAgICAgICAgc3VnZ2VzdGlvbnNDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgIG1vZGFsLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgY29tbWFuZCBpbiBPYnNpZGlhblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ3Nob3ctZmlsZS1pbmZvJyxcbiAgICAgIG5hbWU6ICdTaG93IEZpbGUgSW5mbycsXG4gICAgICBjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGlmIChhY3RpdmVGaWxlKSB7XG4gICAgICAgICAgaWYgKCFjaGVja2luZykge1xuICAgICAgICAgICAgdGhpcy5zaG93RmlsZUluZm8oYWN0aXZlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgTW92ZUJ5VGFnU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgY29uc29sZS5sb2coJ01vdmUgYnkgVGFnIFBsdWdpbiBsb2FkZWQnKTtcbiAgICBcbiAgfVxuXG4gIGFzeW5jIG9udW5sb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKCdNb3ZlIGJ5IFRhZyBQbHVnaW4gdW5sb2FkZWQnKTtcbiAgICAvLyBSZXNldCBzZXR0aW5ncyB0byBkZWZhdWx0XG4gICAgLy8gdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MpO1xuICAgIC8vIGF3YWl0IHRoaXMuc2F2ZURhdGEoe30pOyAvLyBDbGVhciBhbGwgc3RvcmVkIGRhdGFcbiAgfVxuXG4gIGV4dHJhY3RUYWdzKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCB0YWdSZWdleCA9IC8jXFx3Ky9nO1xuICAgIHJldHVybiBjb250ZW50Lm1hdGNoKHRhZ1JlZ2V4KSB8fCBbXTtcbiAgfVxuXG4gIGFzeW5jIHNob3dGaWxlSW5mbyhmaWxlOiBhbnkpIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICB0aGlzLnNob3dGaWxlSW5mb0RpYWxvZyhmaWxlLnBhdGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgc2hvd0ZpbGVJbmZvRGlhbG9nKGZpbGVQYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZVBhdGguc3BsaXQoJy8nKS5wb3AoKTtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5leHRyYWN0VGFncyhjb250ZW50KTtcblxuICAgIGNvbnN0IGRpYWxvZ0NvbnRlbnQgPSBgRmlsZSBOYW1lOiAke2ZpbGVOYW1lfVxcbkxvY2F0aW9uOiAke2ZpbGVQYXRofVxcblRhZ3M6ICR7dGFncy5qb2luKCcsICcpfWA7XG5cbiAgICBjb25zdCBkaWFsb2cgPSBuZXcgSW5mb0RpYWxvZyh0aGlzLmFwcCwgZGlhbG9nQ29udGVudCk7XG4gICAgZGlhbG9nLm9wZW4oKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICBjb25zdCBsb2FkZWREYXRhID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgc2V0dGluZ3MgZGF0YTonLCBsb2FkZWREYXRhKTtcblxuICAgIC8vIENoZWNrIGlmIHRhZ01hcHBpbmdzIGlzIGFuIG9iamVjdCAob2xkIGZvcm1hdClcbiAgICBpZiAobG9hZGVkRGF0YS50YWdNYXBwaW5ncyAmJiB0eXBlb2YgbG9hZGVkRGF0YS50YWdNYXBwaW5ncyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobG9hZGVkRGF0YS50YWdNYXBwaW5ncykpIHtcbiAgICAgIC8vIENvbnZlcnQgb2xkIGZvcm1hdCB0byBuZXcgZm9ybWF0XG4gICAgICBjb25zdCBvbGRNYXBwaW5nczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IGxvYWRlZERhdGEudGFnTWFwcGluZ3M7XG4gICAgICBjb25zdCBjb252ZXJ0ZWRNYXBwaW5nczogVGFnTWFwcGluZ1tdID0gW107XG5cbiAgICAgIC8vIEdyb3VwIG1hcHBpbmdzIGJ5IGZvbGRlclxuICAgICAgY29uc3QgZm9sZGVyVG9UYWdzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG9sZE1hcHBpbmdzKS5mb3JFYWNoKChbdGFnLCBmb2xkZXJdKSA9PiB7XG4gICAgICAgIGlmICghZm9sZGVyVG9UYWdzW2ZvbGRlcl0pIHtcbiAgICAgICAgICBmb2xkZXJUb1RhZ3NbZm9sZGVyXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZvbGRlclRvVGFnc1tmb2xkZXJdLnB1c2godGFnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgbmV3IG1hcHBpbmdzXG4gICAgICBPYmplY3QuZW50cmllcyhmb2xkZXJUb1RhZ3MpLmZvckVhY2goKFtmb2xkZXIsIHRhZ3NdKSA9PiB7XG4gICAgICAgIGNvbnZlcnRlZE1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICAgICAgZm9sZGVyOiBmb2xkZXIsXG4gICAgICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2V0dGluZ3MudGFnTWFwcGluZ3MgPSBjb252ZXJ0ZWRNYXBwaW5ncztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IGluIG9sZCBmb3JtYXQsIGFzc2lnbiBkaXJlY3RseVxuICAgICAgdGhpcy5zZXR0aW5ncy50YWdNYXBwaW5ncyA9IGxvYWRlZERhdGEudGFnTWFwcGluZ3MgfHwgW107XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0xvYWRlZCBleGNsdWRlZCBmb2xkZXJzOicsIGxvYWRlZERhdGEuZXhjbHVkZWRGb2xkZXJzKTtcbiAgICBjb25zb2xlLmxvZygnTG9hZGVkIGxpbWl0ZWQgZm9sZGVyczonLCBsb2FkZWREYXRhLmxpbWl0ZWRGb2xkZXJzKTtcblxuICAgIC8vIE1lcmdlIHdpdGggZGVmYXVsdCBzZXR0aW5nc1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7IC4uLkRFRkFVTFRfU0VUVElOR1MsIC4uLnRoaXMuc2V0dGluZ3MgfTtcbiAgfVxuXG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICBjb25zb2xlLmxvZygnU2F2aW5nIHNldHRpbmdzIGRhdGE6JywgdGhpcy5zZXR0aW5ncyk7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxufVxuXG5jbGFzcyBNb3ZlQnlUYWdNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgcHJpdmF0ZSBzZXR0aW5nczogTW92ZUJ5VGFnU2V0dGluZ3M7XG4gIHByaXZhdGUgcGx1Z2luOiBNb3ZlQnlUYWc7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTW92ZUJ5VGFnKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLnNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaG93Q29uZmlybWF0aW9uRGlhbG9nKG1vdmVtZW50czogQXJyYXk8eyBmaWxlOiBURmlsZTsgdGFyZ2V0UGF0aDogc3RyaW5nIH0+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBtb2RhbCA9IG5ldyBNb2RhbCh0aGlzLmFwcCk7XG4gICAgICBtb2RhbC5jb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQ29uZmlybSBGaWxlIE1vdmVtZW50cycgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1vZGFsLmNvbnRlbnRFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb3ZlLWJ5LXRhZy1jb25maXJtYXRpb24nIH0pO1xuICAgICAgY29udGFpbmVyLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgQWJvdXQgdG8gbW92ZSAke21vdmVtZW50cy5sZW5ndGh9IGZpbGVzOmAgfSk7XG5cbiAgICAgIGNvbnN0IGxpc3QgPSBjb250YWluZXIuY3JlYXRlRWwoJ3VsJyk7XG4gICAgICBtb3ZlbWVudHMuc2xpY2UoMCwgMTApLmZvckVhY2goKHsgZmlsZSwgdGFyZ2V0UGF0aCB9KSA9PiB7XG4gICAgICAgIGxpc3QuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiBgJHtmaWxlLnBhdGh9IOKGkiAke3RhcmdldFBhdGh9YCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobW92ZW1lbnRzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIGNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHsgdGV4dDogYC4uLmFuZCAke21vdmVtZW50cy5sZW5ndGggLSAxMH0gbW9yZSBmaWxlc2AgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb3ZlLWJ5LXRhZy1idXR0b25zJyB9KTtcblxuICAgICAgYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDYW5jZWwnIH0pXG4gICAgICAgIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDb25maXJtJyB9KVxuICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgbW9kYWwub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIHN1Z2dlc3Rpb25zIHdoZW4gbW9kYWwgaXMgY2xvc2VkXG4gICAgICBjb25zdCBzdWdnZXN0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb2xkZXItc3VnZ2VzdGlvbnMnKTtcbiAgICAgIGlmIChzdWdnZXN0aW9uc0NvbnRhaW5lcikge1xuICAgICAgICBzdWdnZXN0aW9uc0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIG1vZGFsLm9wZW4oKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuc2V0VGV4dCgnTW92ZSBmaWxlcyBiYXNlZCBvbiB0aGVpciB0YWdzJyk7XG4gICAgdGhpcy5wbHVnaW4ubG9nKCdPcGVuaW5nIE1vdmUgYnkgVGFnIG1vZGFsJyk7XG5cbiAgICAvLyBBZGQgYSBidXR0b24gdG8gdHJpZ2dlciB0aGUgZmlsZSBtb3ZlbWVudCBwcm9jZXNzXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLmFkZEJ1dHRvbigoYnRuKSA9PiBidG5cbiAgICAgICAgLnNldEJ1dHRvblRleHQoJ01vdmUgRmlsZXMnKVxuICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5tb3ZlRmlsZXNCeVRhZygpO1xuICAgICAgICB9KSk7XG4gIH1cblxuICBhc3luYyBtb3ZlRmlsZXNCeVRhZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wbHVnaW4ubG9nKCdTdGFydGluZyBmaWxlIG1vdmVtZW50IHByb2Nlc3MuLi4nKTtcbiAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcihmaWxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MubGltaXRlZEZvbGRlcnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy5saW1pdGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aChmb2xkZXIpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wbHVnaW4ubG9nKGBGb3VuZCAke2ZpbGVzLmxlbmd0aH0gbWFya2Rvd24gZmlsZXMgdG90YWxgKTtcblxuICAgICAgY29uc3QgbW92ZW1lbnRzOiBBcnJheTx7IGZpbGU6IFRGaWxlOyB0YXJnZXRQYXRoOiBzdHJpbmcgfT4gPSBbXTtcblxuICAgICAgLy8gRmlyc3QsIHBsYW4gYWxsIG1vdmVtZW50c1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIHRoaXMucGx1Z2luLmxvZyhgUHJvY2Vzc2luZyBmaWxlOiAke2ZpbGUucGF0aH1gKTtcblxuICAgICAgICAvLyBOb3JtYWxpemUgZmlsZSBwYXRoXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlUGF0aCA9IGZpbGUucGF0aC5zdGFydHNXaXRoKCcvJykgPyBmaWxlLnBhdGggOiAnLycgKyBmaWxlLnBhdGg7XG5cbiAgICAgICAgLy8gU2tpcCBmaWxlcyBpbiBleGNsdWRlZCBmb2xkZXJzXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmV4Y2x1ZGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZvbGRlciA9IGZvbGRlci5zdGFydHNXaXRoKCcvJykgPyBmb2xkZXIgOiAnLycgKyBmb2xkZXI7XG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aC5zdGFydHNXaXRoKG5vcm1hbGl6ZWRGb2xkZXIpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHRoaXMucGx1Z2luLmxvZyhgU2tpcHBpbmcgZXhjbHVkZWQgZmlsZTogJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YWdzID0gYXdhaXQgdGhpcy5leHRyYWN0VGFncyhmaWxlKTtcbiAgICAgICAgdGhpcy5wbHVnaW4ubG9nKGBGb3VuZCB0YWdzIGluICR7ZmlsZS5wYXRofTogJHt0YWdzLmpvaW4oJywgJykgfHwgJ25vbmUnfWApO1xuXG4gICAgICAgIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5nZXRUYXJnZXRGb2xkZXJGb3JUYWdzKHRhZ3MpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldEZvbGRlcjogc3RyaW5nIHwgbnVsbCA9IG1hdGNoZXNbMF0ubWFwcGluZy5mb2xkZXI7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLCBzaG93IGRpYWxvZyBmb3IgdXNlciB0byBjaG9vc2VcbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubG9nKGBGb3VuZCBtdWx0aXBsZSBtYXRjaGluZyBmb2xkZXJzIGZvciAke2ZpbGUucGF0aH06ICR7bWF0Y2hlcy5tYXAobSA9PiBtLm1hcHBpbmcuZm9sZGVyKS5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgICB0YXJnZXRGb2xkZXIgPSBhd2FpdCB0aGlzLnNob3dSdWxlQ29uZmxpY3REaWFsb2coZmlsZSwgbWF0Y2hlcyk7XG5cbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXRGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5sb2coYFVzZXIgc2tpcHBlZCBmaWxlICR7ZmlsZS5wYXRofSBkdWUgdG8gcnVsZSBjb25mbGljdGApO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFNraXBwZWQgJHtmaWxlLm5hbWV9IGR1ZSB0byBydWxlIGNvbmZsaWN0YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubG9nKGBTZWxlY3RlZCB0YXJnZXQgZm9sZGVyOiAke3RhcmdldEZvbGRlcn1gKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBgJHt0YXJnZXRGb2xkZXJ9LyR7ZmlsZS5uYW1lfWA7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpbGUgYWxyZWFkeSBleGlzdHMgaW4gdGFyZ2V0XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHModGFyZ2V0UGF0aCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubG9nKGBGaWxlIGFscmVhZHkgZXhpc3RzIGF0IHRhcmdldCBsb2NhdGlvbjogJHt0YXJnZXRQYXRofWApO1xuICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTa2lwcGluZyAke2ZpbGUubmFtZX06IEZpbGUgYWxyZWFkeSBleGlzdHMgaW4gdGFyZ2V0IGxvY2F0aW9uYCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5sb2coYFBsYW5uaW5nIHRvIG1vdmUgJHtmaWxlLnBhdGh9IHRvICR7dGFyZ2V0UGF0aH1gKTtcbiAgICAgICAgICAgIG1vdmVtZW50cy5wdXNoKHsgZmlsZSwgdGFyZ2V0UGF0aCB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubG9nKGBObyBtYXRjaGluZyBmb2xkZXIgZm91bmQgZm9yIHRhZ3M6ICR7dGFncy5qb2luKCcsICcpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5sb2coYE5vIHRhZ3MgZm91bmQgaW4gZmlsZTogJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gZmlsZXMgdG8gbW92ZSwgbm90aWZ5IGFuZCBjbG9zZVxuICAgICAgaWYgKG1vdmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5wbHVnaW4ubG9nKCdObyBmaWxlcyB0byBtb3ZlIC0gbm8gdmFsaWQgdGFnIG1hcHBpbmdzIGZvdW5kJyk7XG4gICAgICAgIG5ldyBOb3RpY2UoJ05vIGZpbGVzIHRvIG1vdmUnKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGx1Z2luLmxvZyhgRm91bmQgJHttb3ZlbWVudHMubGVuZ3RofSBmaWxlcyB0byBtb3ZlYCk7XG5cbiAgICAgIC8vIFNob3cgY29uZmlybWF0aW9uIGlmIGVuYWJsZWRcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbmZpcm1CZWZvcmVNb3ZlKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IHRoaXMuc2hvd0NvbmZpcm1hdGlvbkRpYWxvZyhtb3ZlbWVudHMpO1xuICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgIG5ldyBOb3RpY2UoJ09wZXJhdGlvbiBjYW5jZWxsZWQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUGVyZm9ybSBtb3ZlbWVudHNcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChjb25zdCB7IGZpbGUsIHRhcmdldFBhdGggfSBvZiBtb3ZlbWVudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZW5hbWUoZmlsZSwgdGFyZ2V0UGF0aCk7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTG9nZ2luZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE1vdmVkICR7ZmlsZS5wYXRofSB0byAke3RhcmdldFBhdGh9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBtb3ZlICR7ZmlsZS5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ldyBOb3RpY2UoYFN1Y2Nlc3NmdWxseSBtb3ZlZCAke3N1Y2Nlc3NDb3VudH0gb2YgJHttb3ZlbWVudHMubGVuZ3RofSBmaWxlc2ApO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBuZXcgTm90aWNlKGBFcnJvciBkdXJpbmcgZmlsZSBtb3ZlbWVudDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgY29uc29sZS5lcnJvcignTW92ZSBieSBUYWcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGV4dHJhY3RUYWdzKGZpbGU6IFRGaWxlKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnBsdWdpbi5sb2coYFJlYWRpbmcgY29udGVudCBmcm9tIGZpbGU6ICR7ZmlsZS5wYXRofWApO1xuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICBjb25zdCB0YWdSZWdleCA9IC8jKFtcXHctXSspL2c7XG4gICAgICBjb25zdCB0YWdzID0gW107XG4gICAgICBsZXQgbWF0Y2g7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gdGFnUmVnZXguZXhlYyhjb250ZW50KSkgIT09IG51bGwpIHtcbiAgICAgICAgdGFncy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGx1Z2luLmxvZyhgRXh0cmFjdGVkIHRhZ3MgZnJvbSAke2ZpbGUucGF0aH06ICR7dGFncy5qb2luKCcsICcpIHx8ICdub25lJ31gKTtcbiAgICAgIHJldHVybiB0YWdzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnBsdWdpbi5sb2coYEVycm9yIGV4dHJhY3RpbmcgdGFncyBmcm9tICR7ZmlsZS5wYXRofTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIGdldFRhcmdldEZvbGRlckZvclRhZ3MoZmlsZVRhZ3M6IHN0cmluZ1tdKTogQXJyYXk8eyBtYXBwaW5nOiBUYWdNYXBwaW5nOyBtYXRjaGVkVGFnczogc3RyaW5nW10gfT4ge1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnRhZ01hcHBpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbmV3IE5vdGljZSgnTm8gbWFwcGluZ3MgZGVmaW5lZC4nKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnBsdWdpbi5sb2coYENoZWNraW5nIHRhZyBtYXBwaW5ncyBmb3IgdGFnczogJHtmaWxlVGFncy5qb2luKCcsICcpfWApO1xuICAgIHRoaXMucGx1Z2luLmxvZyhgQXZhaWxhYmxlIG1hcHBpbmdzOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuc2V0dGluZ3MudGFnTWFwcGluZ3MpfWApO1xuXG4gICAgLy8gQ29udmVydCBmaWxlIHRhZ3MgdG8gbG93ZXJjYXNlIGZvciBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nXG4gICAgY29uc3QgbG93ZXJGaWxlVGFncyA9IGZpbGVUYWdzLm1hcCh0YWcgPT4gdGFnLnRvTG93ZXJDYXNlKCkpO1xuICAgIGNvbnN0IG1hdGNoZXM6IEFycmF5PHsgbWFwcGluZzogVGFnTWFwcGluZzsgbWF0Y2hlZFRhZ3M6IHN0cmluZ1tdIH0+ID0gW107XG5cbiAgICAvLyBDaGVjayBlYWNoIG1hcHBpbmdcbiAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgdGhpcy5zZXR0aW5ncy50YWdNYXBwaW5ncykge1xuICAgICAgLy8gQ29udmVydCBtYXBwaW5nIHRhZ3MgdG8gbG93ZXJjYXNlXG4gICAgICBjb25zdCBsb3dlck1hcHBpbmdUYWdzID0gbWFwcGluZy50YWdzLm1hcCh0YWcgPT4gdGFnLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAvLyBUcmFjayB3aGljaCB0YWdzIGZyb20gdGhlIG1hcHBpbmcgd2VyZSBmb3VuZCBpbiB0aGUgZmlsZVxuICAgICAgY29uc3QgbWF0Y2hlZFRhZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIC8vIENoZWNrIGVhY2ggdGFnIGluIHRoZSBtYXBwaW5nXG4gICAgICBmb3IgKGNvbnN0IG1hcHBpbmdUYWcgb2YgbWFwcGluZy50YWdzKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyTWFwcGluZ1RhZyA9IG1hcHBpbmdUYWcudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgZmlsZSB0YWcgbWF0Y2hlcyB0aGlzIG1hcHBpbmcgdGFnXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRmlsZVRhZyA9IGxvd2VyRmlsZVRhZ3MuZmluZChmaWxlVGFnID0+XG4gICAgICAgICAgZmlsZVRhZyA9PT0gbG93ZXJNYXBwaW5nVGFnIHx8XG4gICAgICAgICAgZmlsZVRhZyA9PT0gbG93ZXJNYXBwaW5nVGFnICsgJ3MnIHx8XG4gICAgICAgICAgZmlsZVRhZy5zbGljZSgwLCAtMSkgPT09IGxvd2VyTWFwcGluZ1RhZ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtYXRjaGluZ0ZpbGVUYWcpIHtcbiAgICAgICAgICBtYXRjaGVkVGFncy5wdXNoKG1hcHBpbmdUYWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFsbCB0YWdzIGluIHRoZSBtYXBwaW5nIHdlcmUgZm91bmQsIGl0J3MgYSBtYXRjaFxuICAgICAgaWYgKG1hdGNoZWRUYWdzLmxlbmd0aCA9PT0gbWFwcGluZy50YWdzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnBsdWdpbi5sb2coYEZvdW5kIG1hdGNoaW5nIG1hcHBpbmc6ICR7bWFwcGluZy50YWdzLmpvaW4oJyArICcpfSDihpIgJHttYXBwaW5nLmZvbGRlcn1gKTtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHsgbWFwcGluZywgbWF0Y2hlZFRhZ3MgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnBsdWdpbi5sb2coJ05vIG1hdGNoaW5nIGZvbGRlciBmb3VuZCBmb3IgdGFncycpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaG93UnVsZUNvbmZsaWN0RGlhbG9nKGZpbGU6IFRGaWxlLCBtYXRjaGVzOiBBcnJheTx7IG1hcHBpbmc6IFRhZ01hcHBpbmc7IG1hdGNoZWRUYWdzOiBzdHJpbmdbXSB9Pik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwodGhpcy5hcHApO1xuICAgICAgbW9kYWwudGl0bGVFbC5zZXRUZXh0KGBcIiR7ZmlsZS5uYW1lfVwiYCk7XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1vZGFsLmNvbnRlbnRFbC5jcmVhdGVFbCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgIHRleHQ6IGBUaGlzIGZpbGUgbWF0Y2hlcyBtdWx0aXBsZSB0YWcgcnVsZXMuIFBsZWFzZSBzZWxlY3Qgd2hpY2ggZm9sZGVyIHRvIG1vdmUgaXQgdG86YFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxpc3QgPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicpO1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKCh7IG1hcHBpbmcsIG1hdGNoZWRUYWdzIH0pID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0gbGlzdC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb3ZlLWJ5LXRhZy1ydWxlLW9wdGlvbicgfSk7XG5cbiAgICAgICAgY29uc3QgYnV0dG9uID0gcm93LmNyZWF0ZUVsKCdidXR0b24nLCB7XG4gICAgICAgICAgdGV4dDogYE1vdmUgdG8gJHttYXBwaW5nLmZvbGRlcn0gKHRhZ3M6ICR7bWFwcGluZy50YWdzLm1hcCh0ID0+ICcjJyArIHQpLmpvaW4oJyArICcpfSlgLFxuICAgICAgICAgIGNsczogJ21vZC1jdGEnXG4gICAgICAgIH0pO1xuICAgICAgICBidXR0b24uc3R5bGUubWFyZ2luQm90dG9tID0gJzEwcHgnOyAvLyBBZGQgbWFyZ2luIHRvIHRoZSBib3R0b20gb2YgdGhlIGJ1dHRvblxuXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgIHJlc29sdmUobWFwcGluZy5mb2xkZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgY2FuY2VsIGJ1dHRvblxuICAgICAgY29uc3QgY2FuY2VsQnV0dG9uID0gY29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7XG4gICAgICAgIHRleHQ6ICdTa2lwIHRoaXMgZmlsZScsXG4gICAgICAgIGNsczogJ21vdmUtYnktdGFnLWNhbmNlbCdcbiAgICAgIH0pO1xuXG4gICAgICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9KTtcblxuICAgICAgbW9kYWwub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIHN1Z2dlc3Rpb25zIHdoZW4gbW9kYWwgaXMgY2xvc2VkXG4gICAgICBjb25zdCBzdWdnZXN0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb2xkZXItc3VnZ2VzdGlvbnMnKTtcbiAgICAgIGlmIChzdWdnZXN0aW9uc0NvbnRhaW5lcikge1xuICAgICAgICBzdWdnZXN0aW9uc0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIG1vZGFsLm9wZW4oKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBJbmZvRGlhbG9nIGV4dGVuZHMgTW9kYWwge1xuICBwcml2YXRlIGNvbnRlbnQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGVudDogc3RyaW5nKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5zZXRUZXh0KHRoaXMuY29udGVudCk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICB9XG59XG5cbmNsYXNzIE1vdmVCeVRhZ1NldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcHJpdmF0ZSBmb2xkZXJJbnB1dDogVGV4dENvbXBvbmVudDsgLy8gRGVjbGFyZSBmb2xkZXJJbnB1dCBoZXJlXG4gIHBsdWdpbjogTW92ZUJ5VGFnO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE1vdmVCeVRhZykge1xuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgLy8gR2VuZXJhbCBTZXR0aW5ncyBTZWN0aW9uXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnR2VuZXJhbCBTZXR0aW5ncycgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdDb25maXJtIEJlZm9yZSBNb3ZpbmcnKVxuICAgICAgLnNldERlc2MoJ1Nob3cgY29uZmlybWF0aW9uIGRpYWxvZyBiZWZvcmUgbW92aW5nIGZpbGVzJylcbiAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY29uZmlybUJlZm9yZU1vdmUpXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb25maXJtQmVmb3JlTW92ZSA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdFbmFibGUgTG9nZ2luZycpXG4gICAgICAuc2V0RGVzYygnTG9nIGZpbGUgbW92ZW1lbnRzIHRvIGNvbnNvbGUnKVxuICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmFibGVMb2dnaW5nKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlTG9nZ2luZyA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICAvLyBFeGNsdWRlZCBGb2xkZXJzIFNlY3Rpb25cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdFeGNsdWRlZCBGb2xkZXJzJyB9KTtcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcbiAgICAgIHRleHQ6ICdGaWxlcyBpbiB0aGVzZSBmb2xkZXJzIHdpbGwgbm90IGJlIG1vdmVkLiBPbmUgZm9sZGVyIHBhdGggcGVyIGxpbmUuJyxcbiAgICAgIGNsczogJ3NldHRpbmctaXRlbS1kZXNjcmlwdGlvbidcbiAgICB9KTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLmFkZFRleHRBcmVhKHRleHQgPT4ge1xuICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZSBmcm9tIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkRm9sZGVycyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGVkRm9sZGVycyB8fCBbXTtcbiAgICAgICAgdGV4dC5zZXRWYWx1ZShleGNsdWRlZEZvbGRlcnMuam9pbignXFxuJykpXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdmb2xkZXIxL3N1YmZvbGRlclxcbmZvbGRlcjInKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGVkRm9sZGVycyA9IHZhbHVlLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAubWFwKGYgPT4gZi50cmltKCkpXG4gICAgICAgICAgICAgIC5maWx0ZXIoZiA9PiBmLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIFNwZWNpZmljIEZvbGRlcnMgU2VjdGlvblxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1NwZWNpZmljIEZvbGRlcnMnIH0pO1xuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuICAgICAgdGV4dDogJ0ZpbGVzIHdpbGwgb25seSBiZSBtb3ZlZCBmcm9tIHRoZXNlIGZvbGRlcnMuIE9uZSBmb2xkZXIgcGF0aCBwZXIgbGluZS4nLFxuICAgICAgY2xzOiAnc2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uJ1xuICAgIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuYWRkVGV4dEFyZWEodGV4dCA9PiB7XG4gICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlIGZyb20gc2V0dGluZ3NcbiAgICAgICAgY29uc3QgbGltaXRlZEZvbGRlcnMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5saW1pdGVkRm9sZGVycyB8fCBbXTtcbiAgICAgICAgdGV4dC5zZXRWYWx1ZShsaW1pdGVkRm9sZGVycy5qb2luKCdcXG4nKSlcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2ZvbGRlcjEvc3ViZm9sZGVyXFxuZm9sZGVyMicpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubGltaXRlZEZvbGRlcnMgPSB2YWx1ZS5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgLm1hcChmID0+IGYudHJpbSgpKVxuICAgICAgICAgICAgICAuZmlsdGVyKGYgPT4gZi5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAvLyBUYWcgTWFwcGluZ3MgU2VjdGlvblxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1RhZyBNYXBwaW5ncycgfSk7XG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICB0ZXh0OiAnRGVmaW5lIHdoZXJlIGZpbGVzIHNob3VsZCBiZSBtb3ZlZCBiYXNlZCBvbiB0aGVpciB0YWdzLicsXG4gICAgICBjbHM6ICdzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb24nXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgTmV3IE1hcHBpbmcgYW5kIERlbGV0ZSBBbGwgQnV0dG9ucyBhdCB0aGUgdG9wXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCBOZXcgTWFwcGluZycpXG4gICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlIGl0IHN0YW5kIG91dCBhcyB0aGUgcHJpbWFyeSBhY3Rpb25cbiAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5zaG93TmV3TWFwcGluZ01vZGFsKCkpKTtcblxuICAgIC8vIEV4aXN0aW5nIE1hcHBpbmdzXG4gICAgY29uc3QgbWFwcGluZ3NDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3RhZy1tYXBwaW5ncy1jb250YWluZXInKTtcblxuICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy50YWdNYXBwaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIG1hcHBpbmdzQ29udGFpbmVyLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICB0ZXh0OiAnTm8gdGFnIG1hcHBpbmdzIGRlZmluZWQgeWV0LiBDbGljayBcIkFkZCBOZXcgTWFwcGluZ1wiIHRvIGNyZWF0ZSBvbmUuJyxcbiAgICAgICAgY2xzOiAnc2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU29ydCBtYXBwaW5ncyBieSBmaXJzdCB0YWdcbiAgICBjb25zdCBzb3J0ZWRNYXBwaW5ncyA9IFsuLi50aGlzLnBsdWdpbi5zZXR0aW5ncy50YWdNYXBwaW5nc11cbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnRhZ3NbMF0ubG9jYWxlQ29tcGFyZShiLnRhZ3NbMF0pKTtcblxuICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiBzb3J0ZWRNYXBwaW5ncykge1xuICAgICAgY29uc3QgdGFnRGlzcGxheSA9IG1hcHBpbmcudGFncy5tYXAodCA9PiAnIycgKyB0KS5qb2luKCcgKyAnKTtcblxuICAgICAgbmV3IFNldHRpbmcobWFwcGluZ3NDb250YWluZXIpXG4gICAgICAgIC5zZXROYW1lKHRhZ0Rpc3BsYXkpXG4gICAgICAgIC5zZXREZXNjKGBDdXJyZW50IGRlc3RpbmF0aW9uOiAke21hcHBpbmcuZm9sZGVyfWApXG4gICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFZGl0JylcbiAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNob3dFZGl0TWFwcGluZ01vZGFsKG1hcHBpbmcpO1xuICAgICAgICAgIH0pKTtcbiAgICAgIC8vIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgLy8gICAuc2V0SWNvbigndHJhc2gnKVxuICAgICAgLy8gICAuc2V0VG9vbHRpcCgnRGVsZXRlIG1hcHBpbmcnKVxuICAgICAgLy8gICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAvLyAgICAgaWYgKGF3YWl0IHRoaXMuc2hvd0RlbGV0ZUNvbmZpcm1hdGlvbihtYXBwaW5nKSkge1xuICAgICAgLy8gICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGFnTWFwcGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy50YWdNYXBwaW5nc1xuICAgICAgLy8gICAgICAgICAuZmlsdGVyKG0gPT4gbS5pZCAhPT0gbWFwcGluZy5pZCk7XG4gICAgICAvLyAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIC8vICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKS50b1N0cmluZygzNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNob3dOZXdNYXBwaW5nTW9kYWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwodGhpcy5hcHApO1xuICAgIG1vZGFsLnRpdGxlRWwuc2V0VGV4dCgnQ3JlYXRlIE5ldyBUYWcgTWFwcGluZycpO1xuXG4gICAgY29uc3QgY29udGVudEVsID0gbW9kYWwuY29udGVudEVsO1xuICAgIGxldCB0YWdzSW5wdXQ6IFRleHRDb21wb25lbnQ7XG5cbiAgICAvLyBUYWdzIGlucHV0XG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLnNldE5hbWUoJ1RhZ3MnKVxuICAgICAgLnNldERlc2MoJ0VudGVyIHRhZ3Mgd2l0aG91dCAjIHN5bWJvbCwgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gQWxsIHRhZ3MgbXVzdCBiZSBwcmVzZW50IGZvciB0aGUgcnVsZSB0byBhcHBseS4nKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgIHRhZ3NJbnB1dCA9IHRleHQ7XG4gICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ3RhZzEsIHRhZzIsIHRhZzMnKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gRm9sZGVyIGlucHV0XG4gICAgY29uc3QgZm9sZGVyU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgIC5zZXROYW1lKCdEZXN0aW5hdGlvbiBGb2xkZXInKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgdGhpcy5mb2xkZXJJbnB1dCA9IHRleHQ7XG4gICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ2ZvbGRlci9zdWJmb2xkZXInKTtcbiAgICAgICAgdGV4dC5pbnB1dEVsLnN0eWxlLndpZHRoID0gJzMwMHB4JzsgLy8gTWFrZSBpbnB1dCBmaWVsZCB3aWRlclxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VhcmNoRm9sZGVycyh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlGb2xkZXJTdWdnZXN0aW9ucyhyZXN1bHRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgLy8gQnV0dG9uc1xuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJylcbiAgICAgICAgLm9uQ2xpY2soKCkgPT4gbW9kYWwuY2xvc2UoKSkpXG4gICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCcpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFnc1ZhbHVlID0gdGFnc0lucHV0LmdldFZhbHVlKCkudHJpbSgpO1xuICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZm9sZGVySW5wdXQuZ2V0VmFsdWUoKS50cmltKCk7XG5cbiAgICAgICAgICBpZiAoIXRhZ3NWYWx1ZSB8fCAhZm9sZGVyKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdCb3RoIHRhZ3MgYW5kIGZvbGRlciBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0YWdzID0gdGFnc1ZhbHVlLnNwbGl0KCcsJykubWFwKHQgPT4gdC50cmltKCkpLmZpbHRlcih0ID0+IHQubGVuZ3RoID4gMCk7XG4gICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdBdCBsZWFzdCBvbmUgdGFnIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSB0YWcgY29tYmluYXRpb25zXG4gICAgICAgICAgY29uc3QgdGFnU2V0ID0gbmV3IFNldCh0YWdzLm1hcCh0ID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy50YWdNYXBwaW5ncy5zb21lKG0gPT5cbiAgICAgICAgICAgIG0udGFncy5sZW5ndGggPT09IHRhZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICBtLnRhZ3MuZXZlcnkodCA9PiB0YWdTZXQuaGFzKHQudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnVGhpcyB0YWcgY29tYmluYXRpb24gYWxyZWFkeSBoYXMgYSBtYXBwaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3TWFwcGluZzogVGFnTWFwcGluZyA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgICBmb2xkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGFnTWFwcGluZ3MucHVzaChuZXdNYXBwaW5nKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICB9KSk7XG5cbiAgICBtb2RhbC5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgc3VnZ2VzdGlvbnMgd2hlbiBtb2RhbCBpcyBjbG9zZWRcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbGRlci1zdWdnZXN0aW9ucycpO1xuICAgICAgaWYgKHN1Z2dlc3Rpb25zQ29udGFpbmVyKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25zQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgbW9kYWwub3BlbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZWFyY2hGb2xkZXJzKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgaWYgKCFxdWVyeSkgcmV0dXJuIFtdO1xuICAgIFxuICAgIGNvbnN0IGZvbGRlcnMgPSB0aGlzLmFwcC52YXVsdC5nZXRBbGxGb2xkZXJzKCk7XG4gICAgY29uc29sZS5sb2coJ0FsbCBmb2xkZXJzOicsIGZvbGRlcnMpO1xuICAgIFxuICAgIGxldCBmb2xkZXJQYXRocyA9IGZvbGRlcnMubWFwKGZvbGRlciA9PiB7XG4gICAgICAvLyBFbnN1cmUgbGVhZGluZyBzbGFzaCBmb3Igcm9vdC1sZXZlbCBmb2xkZXJzXG4gICAgICByZXR1cm4gZm9sZGVyLnBhdGggPT09ICcvJyA/ICcvJyA6IChmb2xkZXIucGF0aC5zdGFydHNXaXRoKCcvJykgPyBmb2xkZXIucGF0aCA6ICcvJyArIGZvbGRlci5wYXRoKTtcbiAgICB9KTtcblxuICAgIC8vIElmIGxpbWl0ZWQgZm9sZGVycyBhcmUgc2V0LCBvbmx5IHNob3cgZm9sZGVycyB3aXRoaW4gdGhvc2UgcGF0aHNcbiAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MubGltaXRlZEZvbGRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZExpbWl0ZWRGb2xkZXJzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MubGltaXRlZEZvbGRlcnMubWFwKGZvbGRlciA9PiBcbiAgICAgICAgZm9sZGVyLnN0YXJ0c1dpdGgoJy8nKSA/IGZvbGRlciA6ICcvJyArIGZvbGRlclxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZm9sZGVyUGF0aHMgPSBmb2xkZXJQYXRocy5maWx0ZXIocGF0aCA9PiBcbiAgICAgICAgbm9ybWFsaXplZExpbWl0ZWRGb2xkZXJzLnNvbWUobGltaXRlZEZvbGRlciA9PiBcbiAgICAgICAgICBwYXRoLnN0YXJ0c1dpdGgobGltaXRlZEZvbGRlcikgfHwgbGltaXRlZEZvbGRlci5zdGFydHNXaXRoKHBhdGgpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFwcGx5IHNlYXJjaCBxdWVyeSBmaWx0ZXJcbiAgICBmb2xkZXJQYXRocyA9IGZvbGRlclBhdGhzXG4gICAgICAuZmlsdGVyKHBhdGggPT4gcGF0aC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKVxuICAgICAgLnNvcnQoKTtcbiAgICBcbiAgICByZXR1cm4gZm9sZGVyUGF0aHM7XG4gIH1cblxuICBwcml2YXRlIGRpc3BsYXlGb2xkZXJTdWdnZXN0aW9ucyhmb2xkZXJzOiBzdHJpbmdbXSkge1xuICAgIC8vIENsZWFyIHByZXZpb3VzIHN1Z2dlc3Rpb25zXG4gICAgY29uc3Qgc3VnZ2VzdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9sZGVyLXN1Z2dlc3Rpb25zJyk7XG4gICAgaWYgKHN1Z2dlc3Rpb25zQ29udGFpbmVyKSB7XG4gICAgICBzdWdnZXN0aW9uc0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgc3VnZ2VzdGlvbnMgY29udGFpbmVyXG4gICAgY29uc3QgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbmV3Q29udGFpbmVyLmlkID0gJ2ZvbGRlci1zdWdnZXN0aW9ucyc7XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBuZXdDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcbiAgICBuZXdDb250YWluZXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjY2NjJztcbiAgICBuZXdDb250YWluZXIuc3R5bGUuekluZGV4ID0gJzEwMDAnO1xuXG4gICAgLy8gQWRkIHN1Z2dlc3Rpb25zIHRvIHRoZSBjb250YWluZXJcbiAgICBmb2xkZXJzLmZvckVhY2goZm9sZGVyID0+IHtcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25JdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdWdnZXN0aW9uSXRlbS50ZXh0Q29udGVudCA9IGZvbGRlcjtcbiAgICAgIHN1Z2dlc3Rpb25JdGVtLnN0eWxlLnBhZGRpbmcgPSAnNXB4JztcbiAgICAgIHN1Z2dlc3Rpb25JdGVtLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcblxuICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50IHRvIHNlbGVjdCBmb2xkZXJcbiAgICAgIHN1Z2dlc3Rpb25JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmZvbGRlcklucHV0LnNldFZhbHVlKGZvbGRlcik7IC8vIFNldCB0aGUgaW5wdXQgdmFsdWUgdG8gdGhlIHNlbGVjdGVkIGZvbGRlclxuICAgICAgICBuZXdDb250YWluZXIucmVtb3ZlKCk7IC8vIFJlbW92ZSBzdWdnZXN0aW9ucyBhZnRlciBzZWxlY3Rpb25cbiAgICAgIH0pO1xuXG4gICAgICBuZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc3VnZ2VzdGlvbkl0ZW0pO1xuICAgIH0pO1xuXG4gICAgLy8gUG9zaXRpb24gdGhlIHN1Z2dlc3Rpb25zIGNvbnRhaW5lciB1bmRlciB0aGUgaW5wdXQgZmllbGRcbiAgICBjb25zdCBpbnB1dEVsID0gdGhpcy5mb2xkZXJJbnB1dC5pbnB1dEVsO1xuICAgIGNvbnN0IHJlY3QgPSBpbnB1dEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IG1vZGFsRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwnKTtcbiAgICBjb25zdCBtb2RhbFdpZHRoID0gbW9kYWxFbCA/IG1vZGFsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggOiA1MDA7XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBuZXdDb250YWluZXIuc3R5bGUubGVmdCA9IGAke3JlY3QubGVmdH1weGA7XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLnRvcCA9IGAke3JlY3QuYm90dG9tfXB4YDtcbiAgICBuZXdDb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtNYXRoLm1pbihtb2RhbFdpZHRoIC0gNDAsIDMwMCl9cHhgOyAvLyBVc2UgbW9kYWwgd2lkdGggbWludXMgcGFkZGluZywgbWF4IDUwMHB4XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9ICcyMDBweCc7XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcbiAgICBuZXdDb250YWluZXIuc3R5bGUub3ZlcmZsb3dYID0gJ2hpZGRlbic7XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLnRleHRPdmVyZmxvdyA9ICdlbGxpcHNpcyc7XG4gICAgbmV3Q29udGFpbmVyLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICBcbiAgICAvLyBBcHBlbmQgdGhlIHN1Z2dlc3Rpb25zIGNvbnRhaW5lclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3Q29udGFpbmVyKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2hvd0VkaXRNYXBwaW5nTW9kYWwobWFwcGluZzogVGFnTWFwcGluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKHRoaXMuYXBwKTtcbiAgICBtb2RhbC50aXRsZUVsLnNldFRleHQoJ0VkaXQgVGFnIE1hcHBpbmcnKTtcblxuICAgIGNvbnN0IGNvbnRlbnRFbCA9IG1vZGFsLmNvbnRlbnRFbDtcbiAgICBsZXQgdGFnc0lucHV0OiBUZXh0Q29tcG9uZW50O1xuXG4gICAgLy8gVGFncyBpbnB1dFxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgIC5zZXROYW1lKCdUYWdzJylcbiAgICAgIC5zZXREZXNjKCdFbnRlciB0YWdzIHdpdGhvdXQgIyBzeW1ib2wsIHNlcGFyYXRlZCBieSBjb21tYXMuIEFsbCB0YWdzIG11c3QgYmUgcHJlc2VudCBmb3IgdGhlIHJ1bGUgdG8gYXBwbHkuJylcbiAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICB0YWdzSW5wdXQgPSB0ZXh0O1xuICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCd0YWcxLCB0YWcyLCB0YWczJylcbiAgICAgICAgICAuc2V0VmFsdWUobWFwcGluZy50YWdzLmpvaW4oJywgJykpO1xuICAgICAgfSk7XG5cbiAgICAvLyBGb2xkZXIgaW5wdXRcbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAuc2V0TmFtZSgnRGVzdGluYXRpb24gRm9sZGVyJylcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgIHRoaXMuZm9sZGVySW5wdXQgPSB0ZXh0O1xuICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdmb2xkZXIvc3ViZm9sZGVyJylcbiAgICAgICAgICAuc2V0VmFsdWUobWFwcGluZy5mb2xkZXIpO1xuICAgICAgfSk7XG5cbiAgICAvLyBCdXR0b25zXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgIC5zZXRCdXR0b25UZXh0KCdDYW5jZWwnKVxuICAgICAgICAub25DbGljaygoKSA9PiBtb2RhbC5jbG9zZSgpKSlcbiAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAuc2V0QnV0dG9uVGV4dCgnU2F2ZScpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFnc1ZhbHVlID0gdGFnc0lucHV0LmdldFZhbHVlKCkudHJpbSgpO1xuICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZm9sZGVySW5wdXQuZ2V0VmFsdWUoKS50cmltKCk7XG5cbiAgICAgICAgICBpZiAoIXRhZ3NWYWx1ZSB8fCAhZm9sZGVyKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdCb3RoIHRhZ3MgYW5kIGZvbGRlciBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0YWdzID0gdGFnc1ZhbHVlLnNwbGl0KCcsJykubWFwKHQgPT4gdC50cmltKCkpLmZpbHRlcih0ID0+IHQubGVuZ3RoID4gMCk7XG4gICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdBdCBsZWFzdCBvbmUgdGFnIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSB0YWcgY29tYmluYXRpb25zLCBleGNsdWRpbmcgdGhlIGN1cnJlbnQgbWFwcGluZ1xuICAgICAgICAgIGNvbnN0IHRhZ1NldCA9IG5ldyBTZXQodGFncy5tYXAodCA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MudGFnTWFwcGluZ3Muc29tZShtID0+XG4gICAgICAgICAgICBtLmlkICE9PSBtYXBwaW5nLmlkICYmIC8vIEV4Y2x1ZGUgY3VycmVudCBtYXBwaW5nXG4gICAgICAgICAgICBtLnRhZ3MubGVuZ3RoID09PSB0YWdzLmxlbmd0aCAmJlxuICAgICAgICAgICAgbS50YWdzLmV2ZXJ5KHQgPT4gdGFnU2V0Lmhhcyh0LnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1RoaXMgdGFnIGNvbWJpbmF0aW9uIGFscmVhZHkgaGFzIGEgbWFwcGluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcudGFncyA9IHRhZ3M7XG4gICAgICAgICAgbWFwcGluZy5mb2xkZXIgPSBmb2xkZXI7XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICB9KSk7XG5cbiAgICBtb2RhbC5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgc3VnZ2VzdGlvbnMgd2hlbiBtb2RhbCBpcyBjbG9zZWRcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbGRlci1zdWdnZXN0aW9ucycpO1xuICAgICAgaWYgKHN1Z2dlc3Rpb25zQ29udGFpbmVyKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25zQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgbW9kYWwub3BlbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaG93RGVsZXRlQWxsQ29uZmlybWF0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwodGhpcy5hcHApO1xuICAgICAgbW9kYWwudGl0bGVFbC5zZXRUZXh0KCdEZWxldGUgQWxsIFRhZyBNYXBwaW5ncycpO1xuXG4gICAgICBjb25zdCBjb250ZW50RWwgPSBtb2RhbC5jb250ZW50RWw7XG4gICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgIHRleHQ6ICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIGFsbCB0YWcgbWFwcGluZ3M/IFRoaXMgYWN0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJ1xuICAgICAgfSk7XG5cbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0NhbmNlbCcpXG4gICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgIH0pKVxuICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnRGVsZXRlIEFsbCcpXG4gICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgbW9kYWwub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIHN1Z2dlc3Rpb25zIHdoZW4gbW9kYWwgaXMgY2xvc2VkXG4gICAgICBjb25zdCBzdWdnZXN0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb2xkZXItc3VnZ2VzdGlvbnMnKTtcbiAgICAgIGlmIChzdWdnZXN0aW9uc0NvbnRhaW5lcikge1xuICAgICAgICBzdWdnZXN0aW9uc0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIG1vZGFsLm9wZW4oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2hvd0RlbGV0ZUNvbmZpcm1hdGlvbihtYXBwaW5nOiBUYWdNYXBwaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBtb2RhbCA9IG5ldyBNb2RhbCh0aGlzLmFwcCk7XG4gICAgICBtb2RhbC50aXRsZUVsLnNldFRleHQoJ0RlbGV0ZSBUYWcgTWFwcGluZycpO1xuXG4gICAgICBjb25zdCBjb250ZW50RWwgPSBtb2RhbC5jb250ZW50RWw7XG4gICAgICBjb25zdCB0YWdEaXNwbGF5ID0gbWFwcGluZy50YWdzLm1hcCh0ID0+ICcjJyArIHQpLmpvaW4oJyArICcpO1xuXG4gICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgIHRleHQ6IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoZSBtYXBwaW5nIGZvciAke3RhZ0Rpc3BsYXl9P1xcbmAgK1xuICAgICAgICAgIGBGaWxlcyB3aXRoIHRoZXNlIHRhZ3Mgd2lsbCBubyBsb25nZXIgYmUgbW92ZWQgYXV0b21hdGljYWxseS5gXG4gICAgICB9KTtcblxuICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJylcbiAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfSkpXG4gICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdEZWxldGUnKVxuICAgICAgICAgIC5zZXRXYXJuaW5nKClcbiAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9KSk7XG5cbiAgICAgIG1vZGFsLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cCBzdWdnZXN0aW9ucyB3aGVuIG1vZGFsIGlzIGNsb3NlZFxuICAgICAgY29uc3Qgc3VnZ2VzdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9sZGVyLXN1Z2dlc3Rpb25zJyk7XG4gICAgICBpZiAoc3VnZ2VzdGlvbnNDb250YWluZXIpIHtcbiAgICAgICAgc3VnZ2VzdGlvbnNDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBtb2RhbC5vcGVuKCk7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack://move-by-tag/./main.ts?");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\n\n//# sourceURL=webpack://move-by-tag/./node_modules/tslib/tslib.es6.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.ts");
/******/ 	
/******/ })()
;