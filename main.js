/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MoveByTag
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/models/types.ts
var DEFAULT_SETTINGS = {
  tagMappings: [],
  excludedFolders: [],
  limitedFolders: [],
  confirmBeforeMove: true,
  enableLogging: false
};

// src/ui/MoveByTagSettingTab.ts
var import_obsidian = require("obsidian");

// src/ui/FolderSuggestions.ts
var FolderSuggestions = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Search for folders matching a query
   */
  async searchFolders(query) {
    if (!query)
      return [];
    const folders = this.app.vault.getAllFolders();
    let folderPaths = folders.map((folder) => {
      return folder.path === "/" ? "/" : folder.path.startsWith("/") ? folder.path : "/" + folder.path;
    });
    folderPaths = folderPaths.filter((path) => path.toLowerCase().includes(query.toLowerCase())).sort();
    return folderPaths;
  }
  /**
   * Display folder suggestions dropdown
   */
  displayFolderSuggestions(folders) {
    const existingSuggestions = document.querySelectorAll(".folder-suggestions-container");
    existingSuggestions.forEach((el) => el.remove());
    if (folders.length === 0)
      return;
    const activeElement = document.activeElement;
    if (!(activeElement instanceof HTMLInputElement)) {
      return;
    }
    const settingItemControl = activeElement.closest(".setting-item-control");
    if (!settingItemControl) {
      return;
    }
    settingItemControl.style.position = "relative";
    console.log("Setting up suggestions container with parent:", settingItemControl);
    const newContainer = document.createElement("div");
    newContainer.className = "folder-suggestions-container";
    newContainer.style.position = "absolute";
    newContainer.style.backgroundColor = "var(--background-primary)";
    newContainer.style.border = "1px solid var(--background-modifier-border)";
    newContainer.style.borderRadius = "4px";
    newContainer.style.zIndex = "1000";
    newContainer.style.boxShadow = "0 2px 8px var(--background-modifier-box-shadow)";
    folders.forEach((folder) => {
      const suggestionItem = document.createElement("div");
      suggestionItem.className = "folder-suggestion-item";
      suggestionItem.textContent = folder;
      suggestionItem.style.padding = "8px 12px";
      suggestionItem.style.cursor = "pointer";
      suggestionItem.style.transition = "background-color 0.1s ease";
      suggestionItem.style.textAlign = "left";
      suggestionItem.addEventListener("mouseover", () => {
        suggestionItem.style.backgroundColor = "var(--background-modifier-hover)";
      });
      suggestionItem.addEventListener("mouseout", () => {
        suggestionItem.style.backgroundColor = "";
      });
      suggestionItem.addEventListener("click", () => {
        activeElement.value = folder;
        const event = new Event("input", { bubbles: true });
        activeElement.dispatchEvent(event);
        newContainer.remove();
      });
      newContainer.appendChild(suggestionItem);
    });
    const rect = activeElement.getBoundingClientRect();
    const controlRect = settingItemControl.getBoundingClientRect();
    settingItemControl.appendChild(newContainer);
    newContainer.style.position = "absolute";
    newContainer.style.left = "";
    newContainer.style.right = "0";
    newContainer.style.top = `${rect.height + 4}px`;
    newContainer.style.width = `${rect.width}px`;
    newContainer.style.maxHeight = "200px";
    newContainer.style.overflowY = "auto";
    newContainer.style.overflowX = "hidden";
    newContainer.offsetHeight;
    console.log("Container styles after positioning:", {
      position: newContainer.style.position,
      right: newContainer.style.right,
      left: newContainer.style.left,
      top: newContainer.style.top,
      width: newContainer.style.width
    });
    const clickOutsideHandler = (e) => {
      if (!newContainer.contains(e.target) && e.target !== activeElement) {
        newContainer.remove();
        document.removeEventListener("click", clickOutsideHandler);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", clickOutsideHandler);
    }, 0);
  }
};

// src/services/TagMappingService.ts
var TagMappingService = class {
  /**
   * Generate a unique ID for a tag mapping
   */
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  /**
   * Find matching folders for a set of tags
   */
  getTargetFolderForTags(fileTags, tagMappings) {
    if (tagMappings.length === 0) {
      return [];
    }
    const lowerFileTags = fileTags.map((tag) => tag.toLowerCase());
    const matches = [];
    for (const mapping of tagMappings) {
      const lowerMappingTags = mapping.tags.map((tag) => tag.toLowerCase());
      const matchedTags = [];
      for (const mappingTag of mapping.tags) {
        const lowerMappingTag = mappingTag.toLowerCase();
        const matchingFileTag = lowerFileTags.find(
          (fileTag) => fileTag === lowerMappingTag || fileTag === lowerMappingTag + "s" || fileTag.slice(0, -1) === lowerMappingTag
        );
        if (matchingFileTag) {
          matchedTags.push(mappingTag);
        }
      }
      if (matchedTags.length === mapping.tags.length) {
        matches.push({ mapping, matchedTags });
      }
    }
    return matches;
  }
};

// src/ui/MoveByTagSettingTab.ts
var MoveByTagSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin, settings, saveSettings) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = settings;
    this.saveSettings = saveSettings;
    this.folderSuggestions = new FolderSuggestions(app);
    this.tagMappingService = new TagMappingService();
  }
  createFolderInputSetting(parentEl, placeholder, label) {
    let textComponent = null;
    console.log("Creating folder input setting for:", label);
    new import_obsidian.Setting(parentEl).setName(label).addText((text) => {
      text.setPlaceholder(placeholder);
      text.inputEl.style.width = "300px";
      text.inputEl.setAttribute("data-folder-input", label);
      text.onChange(async (value) => {
        console.log("Input changed:", value);
        const inputEl = text.inputEl;
        const results = await this.folderSuggestions.searchFolders(value);
        if (document.activeElement === inputEl) {
          this.folderSuggestions.displayFolderSuggestions(results);
        }
      });
      textComponent = text;
    });
    if (!textComponent)
      throw new Error("Failed to create text component");
    return textComponent;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Confirm Before Moving").setDesc("Show confirmation dialog before moving files").addToggle((toggle) => toggle.setValue(this.settings.confirmBeforeMove).onChange(async (value) => {
      this.settings.confirmBeforeMove = value;
      await this.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Logging").setDesc("Log file movements to console").addToggle((toggle) => toggle.setValue(this.settings.enableLogging).onChange(async (value) => {
      this.settings.enableLogging = value;
      await this.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Excluded Folders" });
    containerEl.createEl("p", {
      text: "Files in these folders will not be moved. One folder path per line.",
      cls: "setting-item-description"
    });
    this.createFolderInputSetting(containerEl, "Exclude folder/subfolder", "Exclude folder");
    containerEl.createEl("h3", { text: "Specific Folders" });
    containerEl.createEl("p", {
      text: "Files will only be moved from these folders. One folder path per line.",
      cls: "setting-item-description"
    });
    this.createFolderInputSetting(containerEl, "Specific folder/subfolder", "Specific folder");
    containerEl.createEl("h3", { text: "Tag Mappings" });
    containerEl.createEl("p", {
      text: "Define where files should be moved based on their tags.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Add New Mapping").setCta().onClick(() => this.showNewMappingModal()));
    const mappingsContainer = containerEl.createDiv("tag-mappings-container");
    if (this.settings.tagMappings.length === 0) {
      mappingsContainer.createEl("p", {
        text: 'No tag mappings defined yet. Click "Add New Mapping" to create one.',
        cls: "setting-item-description"
      });
    }
    const sortedMappings = [...this.settings.tagMappings].sort((a, b) => a.tags[0].localeCompare(b.tags[0]));
    for (const mapping of sortedMappings) {
      const tagDisplay = mapping.tags.map((t) => "#" + t).join(" + ");
      new import_obsidian.Setting(mappingsContainer).setName(tagDisplay).setDesc(`Current destination: ${mapping.folder}`).addButton((button) => button.setButtonText("Edit").onClick(() => {
        this.showEditMappingModal(mapping);
      }));
    }
  }
  async showNewMappingModal() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Create New Tag Mapping");
    const contentEl = modal.contentEl;
    let tagsInput;
    new import_obsidian.Setting(contentEl).setName("Tags").setDesc("Enter tags without # symbol, separated by commas. All tags must be present for the rule to apply.").addText((text) => {
      tagsInput = text;
      text.setPlaceholder("tag1, tag2, tag3");
    });
    this.createFolderInputSetting(contentEl, "folder/subfolder", "Destination Folder");
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Cancel").onClick(() => modal.close())).addButton((button) => button.setButtonText("Add").setCta().onClick(async () => {
      const tagsValue = tagsInput.getValue().trim();
      const folder = this.createFolderInputSetting(contentEl, "folder/subfolder", "Destination Folder").getValue().trim();
      if (!tagsValue || !folder) {
        new import_obsidian.Notice("Both tags and folder are required");
        return;
      }
      const tags = tagsValue.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      if (tags.length === 0) {
        new import_obsidian.Notice("At least one tag is required");
        return;
      }
      const tagSet = new Set(tags.map((t) => t.toLowerCase()));
      if (this.settings.tagMappings.some(
        (m) => m.tags.length === tags.length && m.tags.every((t) => tagSet.has(t.toLowerCase()))
      )) {
        new import_obsidian.Notice("This tag combination already has a mapping");
        return;
      }
      const newMapping = {
        id: this.tagMappingService.generateId(),
        tags,
        folder
      };
      this.settings.tagMappings.push(newMapping);
      await this.saveSettings();
      this.display();
      modal.close();
    }));
    modal.onClose = () => {
      const suggestionsContainer = document.getElementById("folder-suggestions");
      if (suggestionsContainer) {
        suggestionsContainer.remove();
      }
    };
    modal.open();
  }
  async showEditMappingModal(mapping) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Edit Tag Mapping");
    const contentEl = modal.contentEl;
    let tagsInput;
    new import_obsidian.Setting(contentEl).setName("Tags").setDesc("Enter tags without # symbol, separated by commas. All tags must be present for the rule to apply.").addText((text) => {
      tagsInput = text;
      text.setValue(mapping.tags.join(", "));
    });
    this.createFolderInputSetting(contentEl, "folder/subfolder", "Destination Folder").setValue(mapping.folder);
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Cancel").onClick(() => modal.close())).addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
      if (await this.showDeleteConfirmation(mapping)) {
        this.settings.tagMappings = this.settings.tagMappings.filter((m) => m.id !== mapping.id);
        await this.saveSettings();
        this.display();
        modal.close();
      }
    })).addButton((button) => button.setButtonText("Save").setCta().onClick(async () => {
      const tagsValue = tagsInput.getValue().trim();
      const folder = this.createFolderInputSetting(contentEl, "folder/subfolder", "Destination Folder").getValue().trim();
      if (!tagsValue || !folder) {
        new import_obsidian.Notice("Both tags and folder are required");
        return;
      }
      const tags = tagsValue.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      if (tags.length === 0) {
        new import_obsidian.Notice("At least one tag is required");
        return;
      }
      const tagSet = new Set(tags.map((t) => t.toLowerCase()));
      if (this.settings.tagMappings.some(
        (m) => m.id !== mapping.id && m.tags.length === tags.length && m.tags.every((t) => tagSet.has(t.toLowerCase()))
      )) {
        new import_obsidian.Notice("This tag combination already has a mapping");
        return;
      }
      const index = this.settings.tagMappings.findIndex((m) => m.id === mapping.id);
      if (index !== -1) {
        this.settings.tagMappings[index] = {
          ...mapping,
          tags,
          folder
        };
        await this.saveSettings();
        this.display();
        modal.close();
      }
    }));
    modal.onClose = () => {
      const suggestionsContainer = document.getElementById("folder-suggestions");
      if (suggestionsContainer) {
        suggestionsContainer.remove();
      }
    };
    modal.open();
  }
  async showDeleteConfirmation(mapping) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Delete Mapping");
      const contentEl = modal.contentEl;
      contentEl.createEl("p", {
        text: `Are you sure you want to delete the mapping for tags: ${mapping.tags.map((t) => "#" + t).join(" + ")}?`
      });
      new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Cancel").onClick(() => {
        modal.close();
        resolve(false);
      })).addButton((button) => button.setButtonText("Delete").setWarning().onClick(() => {
        modal.close();
        resolve(true);
      }));
      modal.open();
    });
  }
};

// src/utils/FileUtils.ts
var FileUtils = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Extract tags from file content
   */
  extractTags(content) {
    const tagRegex = /#([\w-]+)/g;
    const tags = [];
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.push(match[1]);
    }
    return tags;
  }
  /**
   * Extract tags from a file
   */
  async extractTagsFromFile(file) {
    try {
      const content = await this.app.vault.read(file);
      return this.extractTags(content);
    } catch (error) {
      console.error(`Error extracting tags from ${file.path}:`, error);
      return [];
    }
  }
  /**
   * Check if a file path is in an excluded folder
   */
  isInExcludedFolder(filePath, excludedFolders) {
    const normalizedFilePath = filePath.startsWith("/") ? filePath : "/" + filePath;
    return excludedFolders.some((folder) => {
      const normalizedFolder = folder.startsWith("/") ? folder : "/" + folder;
      return normalizedFilePath.startsWith(normalizedFolder);
    });
  }
  /**
   * Check if a file path is in a limited folder
   */
  isInLimitedFolder(filePath, limitedFolders) {
    if (limitedFolders.length === 0)
      return true;
    const normalizedFilePath = filePath.startsWith("/") ? filePath.substring(1) : filePath;
    return limitedFolders.some((folder) => {
      const normalizedFolder = folder === "/" ? "/" : folder.replace(/^\//, "");
      return normalizedFilePath.startsWith(normalizedFolder);
    });
  }
};

// src/ui/InfoDialog.ts
var import_obsidian3 = require("obsidian");

// src/services/FileMovementService.ts
var import_obsidian2 = require("obsidian");

// src/services/LoggingService.ts
var LoggingService = class {
  constructor(app) {
    this.logFolderPath = "Resources/Logs/MoveByTag";
    this.app = app;
  }
  /**
   * Ensure the log directory exists
   */
  async ensureLogDirectory() {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists("Resources")) {
      await adapter.mkdir("Resources");
    }
    if (!await adapter.exists("Resources/Logs")) {
      await adapter.mkdir("Resources/Logs");
    }
    if (!await adapter.exists(this.logFolderPath)) {
      await adapter.mkdir(this.logFolderPath);
    }
  }
  /**
   * Generate a timestamp in YYYYMMDD HH:MM:SS format
   */
  getTimestamp() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const hours = String(now.getHours()).padStart(2, "0");
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const seconds = String(now.getSeconds()).padStart(2, "0");
    return `${year}${month}${day} ${hours}:${minutes}:${seconds}`;
  }
  /**
   * Generate a log filename based on operation type and current date/time
   */
  getLogFilename(operationType) {
    const timestamp = this.getTimestamp().replace(":", "").replace(":", "");
    return `${operationType}_${timestamp}.md`;
  }
  /**
   * Create a log entry for a file movement
   */
  createLogEntry(file, destinationPath, tags, hadRuleConflict, wasSkipped, skipReason = "" /* NONE */) {
    const getDirectoryPath = (path) => {
      const lastSlashIndex = path.lastIndexOf("/");
      const dirPath = lastSlashIndex >= 0 ? path.substring(0, lastSlashIndex) : "";
      return dirPath && !dirPath.startsWith("/") ? `/${dirPath}` : dirPath;
    };
    const sourceDir = getDirectoryPath(file.path);
    let destDir = "";
    if (destinationPath) {
      destDir = getDirectoryPath(destinationPath);
    }
    return {
      timestamp: this.getTimestamp(),
      fileName: file.name,
      sourcePath: sourceDir,
      destinationPath: destDir,
      tags,
      hadRuleConflict,
      wasSkipped,
      skipReason
    };
  }
  /**
   * Save log entries to a Markdown file
   */
  async saveLogEntries(operationType, entries) {
    await this.ensureLogDirectory();
    const filename = this.getLogFilename(operationType);
    const fullPath = `${this.logFolderPath}/${filename}`;
    let mdContent = `# File Movement Log - ${this.getOperationTypeLabel(operationType)}

`;
    mdContent += `Generated: ${this.getTimestamp()}

`;
    mdContent += `| File Name | Source Path | Destination Path | Tags | Status | Reason |
`;
    mdContent += `| --------- | ----------- | ---------------- | ---- | ------ | ------ |
`;
    for (const entry of entries) {
      const status = entry.wasSkipped ? "\u274C" : "\u2705";
      const reason = entry.skipReason || (entry.hadRuleConflict ? "Rule conflict resolved" : "");
      mdContent += `| ${this.escapeMarkdownField(entry.fileName)} | ${this.escapeMarkdownField(entry.sourcePath)} | ${this.escapeMarkdownField(entry.destinationPath)} | ${this.escapeMarkdownField(entry.tags.join(", "))} | ${status} | ${reason} |
`;
    }
    const movedCount = entries.filter((e) => !e.wasSkipped).length;
    const skippedCount = entries.filter((e) => e.wasSkipped).length;
    mdContent += `
## Summary

`;
    mdContent += `- Total files processed: ${entries.length}
`;
    mdContent += `- Files moved: ${movedCount}
`;
    mdContent += `- Files skipped: ${skippedCount}
`;
    await this.app.vault.adapter.write(fullPath, mdContent);
    return fullPath;
  }
  /**
   * Get a human-readable label for the operation type
   */
  getOperationTypeLabel(operationType) {
    switch (operationType) {
      case "SFL" /* SINGLE_FILE */:
        return "Single File Move";
      case "CFD" /* CURRENT_FOLDER */:
        return "Current Folder Move";
      case "AFL" /* ALL_FOLDERS */:
        return "All Folders Move";
      default:
        return "File Movement";
    }
  }
  /**
   * Escape a field for Markdown table
   */
  escapeMarkdownField(field) {
    if (!field)
      return "";
    return field.replace(/\|/g, "\\|").replace(/\n/g, "<br>");
  }
};

// src/services/FileMovementService.ts
var FileMovementService = class {
  constructor(app, settings, fileUtils, tagMappingService, logger) {
    this.app = app;
    this.settings = settings;
    this.fileUtils = fileUtils;
    this.tagMappingService = tagMappingService;
    this.logger = logger;
    this.loggingService = new LoggingService(app);
  }
  /**
   * Move files based on their tags
   * @param scope The scope of files to process (single file, current folder, all folders)
   * @param contextFile The file to use as context (for single file or current folder scope)
   * @returns Result of the operation
   */
  async moveFiles(scope = "all_folders" /* ALL_FOLDERS */, contextFile) {
    this.logger(`Starting file movement process with scope: ${scope}`);
    const operationType = this.getMoveOperationType(scope);
    const filesToProcess = await this.getFilesToProcess(scope, contextFile);
    if (filesToProcess.length === 0) {
      this.logger("No files to process");
      new import_obsidian2.Notice("No files to process");
      return { total: 0, moved: 0 };
    }
    this.logger(`Found ${filesToProcess.length} files to process`);
    const movements = [];
    const logEntries = [];
    const ruleConflicts = {};
    for (const file of filesToProcess) {
      this.logger(`Processing file: ${file.path}`);
      if (scope === "all_folders" /* ALL_FOLDERS */ && this.fileUtils.isInExcludedFolder(file.path, this.settings.excludedFolders)) {
        this.logger(`Skipping excluded file: ${file.path}`);
        continue;
      }
      const tags = await this.fileUtils.extractTagsFromFile(file);
      this.logger(`Found tags in ${file.path}: ${tags.join(", ") || "none"}`);
      if (tags.length > 0) {
        const matches = this.tagMappingService.getTargetFolderForTags(tags, this.settings.tagMappings);
        if (matches.length > 0) {
          let targetFolder = matches[0].mapping.folder;
          let hadRuleConflict = false;
          if (matches.length > 1) {
            hadRuleConflict = true;
            ruleConflicts[file.path] = true;
            this.logger(`Found multiple matching folders for ${file.path}: ${matches.map((m) => m.mapping.folder).join(", ")}`);
            targetFolder = await this.showRuleConflictDialog(file, matches);
            if (!targetFolder) {
              this.logger(`User skipped file ${file.path} due to rule conflict`);
              new import_obsidian2.Notice(`Skipped ${file.name} due to rule conflict`);
              logEntries.push(this.loggingService.createLogEntry(
                file,
                null,
                tags,
                hadRuleConflict,
                true,
                "Rule conflict" /* RULE_CONFLICT */
              ));
              continue;
            }
          }
          this.logger(`Selected target folder: ${targetFolder}`);
          const targetPath = `${targetFolder}/${file.name}`;
          const currentFolder = file.path.substring(0, file.path.lastIndexOf("/"));
          if (currentFolder === targetFolder) {
            this.logger(`File is already in the correct folder: ${targetFolder}`);
            new import_obsidian2.Notice(`Skipping ${file.name}: Already in correct folder`);
            logEntries.push(this.loggingService.createLogEntry(
              file,
              targetPath,
              tags,
              hadRuleConflict,
              true,
              "Already in correct folder" /* ALREADY_IN_PLACE */
            ));
            continue;
          }
          if (await this.app.vault.adapter.exists(targetPath)) {
            this.logger(`File already exists at target location: ${targetPath}`);
            new import_obsidian2.Notice(`Skipping ${file.name}: File already exists in target location`);
            logEntries.push(this.loggingService.createLogEntry(
              file,
              targetPath,
              tags,
              hadRuleConflict,
              true,
              "File exists at destination" /* FILE_EXISTS */
            ));
            continue;
          }
          this.logger(`Planning to move ${file.path} to ${targetPath}`);
          movements.push({ file, targetPath });
          logEntries.push(this.loggingService.createLogEntry(
            file,
            targetPath,
            tags,
            hadRuleConflict,
            false
          ));
        } else {
          this.logger(`No matching folder found for tags: ${tags.join(", ")}`);
          logEntries.push(this.loggingService.createLogEntry(
            file,
            null,
            tags,
            false,
            true,
            "No matching rules" /* NO_MATCHING_RULES */
          ));
        }
      } else {
        this.logger(`No tags found in file: ${file.path}`);
        logEntries.push(this.loggingService.createLogEntry(
          file,
          null,
          [],
          false,
          true,
          "No tags" /* NO_TAGS */
        ));
      }
    }
    if (movements.length === 0) {
      this.logger("No files to move - no valid tag mappings found");
      new import_obsidian2.Notice("No files to move");
      if (logEntries.length > 0) {
        const logPath2 = await this.loggingService.saveLogEntries(operationType, logEntries);
        this.logger(`Log saved to ${logPath2}`);
      }
      return { total: 0, moved: 0 };
    }
    this.logger(`Found ${movements.length} files to move`);
    if (this.settings.confirmBeforeMove) {
      const confirmed = await this.showBatchConfirmationDialog(movements);
      if (!confirmed) {
        new import_obsidian2.Notice("Operation cancelled");
        for (const entry of logEntries) {
          if (!entry.wasSkipped) {
            entry.wasSkipped = true;
            entry.skipReason = "Operation cancelled" /* OPERATION_CANCELLED */;
          }
        }
        const logPath2 = await this.loggingService.saveLogEntries(operationType, logEntries);
        this.logger(`Log saved to ${logPath2}`);
        return { total: movements.length, moved: 0 };
      }
    }
    let successCount = 0;
    for (const { file, targetPath } of movements) {
      try {
        await this.app.vault.rename(file, targetPath);
        successCount++;
        this.logger(`Moved ${file.path} to ${targetPath}`);
      } catch (error) {
        new import_obsidian2.Notice(`Failed to move ${file.name}: ${error.message}`);
        const logEntry = logEntries.find(
          (entry) => entry.fileName === file.name && entry.sourcePath === file.path.substring(0, file.path.lastIndexOf("/")) && entry.destinationPath === targetPath.substring(0, targetPath.lastIndexOf("/"))
        );
        if (logEntry) {
          logEntry.wasSkipped = true;
          logEntry.skipReason = "Error during move" /* ERROR */;
        }
      }
    }
    new import_obsidian2.Notice(`Successfully moved ${successCount} of ${movements.length} files`);
    const logPath = await this.loggingService.saveLogEntries(operationType, logEntries);
    this.logger(`Log saved to ${logPath}`);
    return { total: movements.length, moved: successCount };
  }
  /**
   * Get the move operation type based on scope
   */
  getMoveOperationType(scope) {
    switch (scope) {
      case "single_file" /* SINGLE_FILE */:
        return "SFL" /* SINGLE_FILE */;
      case "current_folder" /* CURRENT_FOLDER */:
        return "CFD" /* CURRENT_FOLDER */;
      case "all_folders" /* ALL_FOLDERS */:
      default:
        return "AFL" /* ALL_FOLDERS */;
    }
  }
  /**
   * Get files to process based on scope
   */
  async getFilesToProcess(scope, contextFile) {
    switch (scope) {
      case "single_file" /* SINGLE_FILE */:
        if (!contextFile) {
          this.logger("No context file provided for single file scope");
          return [];
        }
        return [contextFile];
      case "current_folder" /* CURRENT_FOLDER */:
        if (!contextFile) {
          this.logger("No context file provided for current folder scope");
          return [];
        }
        const currentFolder = contextFile.path.substring(0, contextFile.path.lastIndexOf("/"));
        this.logger(`Processing files in folder: ${currentFolder}`);
        return this.app.vault.getMarkdownFiles().filter((file) => {
          const fileFolder = file.path.substring(0, file.path.lastIndexOf("/"));
          return fileFolder === currentFolder;
        });
      case "all_folders" /* ALL_FOLDERS */:
      default:
        const files = this.app.vault.getMarkdownFiles();
        if (this.settings.limitedFolders.length > 0) {
          return files.filter(
            (file) => this.fileUtils.isInLimitedFolder(file.path, this.settings.limitedFolders)
          );
        }
        return files;
    }
  }
  /**
   * Move a single file based on its tags
   */
  async moveFile(file) {
    return this.moveFiles("single_file" /* SINGLE_FILE */, file);
  }
  /**
   * Show confirmation dialog for a single file move
   */
  async showConfirmationDialog(file, targetPath) {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Confirm File Movement");
      const { contentEl } = modal;
      contentEl.createEl("p", {
        text: `Are you sure you want to move this file?`
      });
      const fileInfo = contentEl.createDiv();
      fileInfo.style.margin = "10px 0";
      fileInfo.style.padding = "10px";
      fileInfo.style.backgroundColor = "var(--background-secondary)";
      fileInfo.style.borderRadius = "4px";
      fileInfo.createDiv({
        text: `From: ${file.path}`,
        cls: "move-confirmation-path"
      });
      fileInfo.createDiv({
        text: `To: ${targetPath}`,
        cls: "move-confirmation-path"
      });
      const buttonContainer = contentEl.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "flex-end";
      buttonContainer.style.marginTop = "20px";
      const cancelButton = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-warning"
      });
      cancelButton.style.marginRight = "10px";
      const confirmButton = buttonContainer.createEl("button", {
        text: "Move",
        cls: "mod-cta"
      });
      cancelButton.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      confirmButton.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * Show confirmation dialog for batch file movements
   */
  async showBatchConfirmationDialog(movements) {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Confirm File Movements");
      const { contentEl } = modal;
      contentEl.createEl("p", {
        text: `You are about to move ${movements.length} file(s). Continue?`
      });
      const fileList = contentEl.createEl("div", { cls: "move-by-tag-file-list" });
      fileList.style.maxHeight = "200px";
      fileList.style.overflow = "auto";
      fileList.style.marginBottom = "10px";
      fileList.style.border = "1px solid var(--background-modifier-border)";
      fileList.style.borderRadius = "4px";
      fileList.style.padding = "10px";
      movements.forEach(({ file, targetPath }) => {
        const item = fileList.createEl("div", { cls: "move-by-tag-file-item" });
        item.style.marginBottom = "5px";
        item.style.display = "flex";
        const fromEl = item.createSpan({ text: file.path });
        fromEl.style.marginRight = "10px";
        const arrowEl = item.createSpan({ text: "\u2192" });
        arrowEl.style.margin = "0 10px";
        arrowEl.style.color = "var(--text-muted)";
        const toEl = item.createSpan({ text: targetPath });
      });
      const buttonContainer = contentEl.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "flex-end";
      buttonContainer.style.marginTop = "20px";
      const cancelButton = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-warning"
      });
      cancelButton.style.marginRight = "10px";
      const confirmButton = buttonContainer.createEl("button", {
        text: "Move Files",
        cls: "mod-cta"
      });
      cancelButton.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      confirmButton.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * Show rule conflict dialog
   */
  async showRuleConflictDialog(file, matches) {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Multiple Rules Match");
      const { contentEl } = modal;
      contentEl.createEl("p", {
        text: `Multiple rules match the file "${file.name}". Please select which folder to use:`
      });
      const container = contentEl.createEl("div");
      const list = container.createEl("div");
      const form = list.createEl("form", { cls: "move-by-tag-rule-form" });
      form.style.marginBottom = "10px";
      form.addEventListener("submit", (e) => {
        e.preventDefault();
      });
      matches.forEach(({ mapping, matchedTags }, index) => {
        const row = form.createEl("div", { cls: "move-by-tag-rule-option" });
        row.style.marginBottom = "10px";
        row.style.display = "flex";
        row.style.alignItems = "center";
        const radio = row.createEl("input", {
          type: "radio",
          attr: {
            name: "folder-option",
            id: `folder-option-${index}`,
            value: mapping.folder
          }
        });
        if (index === 0) {
          radio.checked = true;
        }
        const label = row.createEl("label", {
          text: `Move to ${mapping.folder} (tags: ${mapping.tags.map((t) => "#" + t).join(" + ")})`,
          attr: { for: `folder-option-${index}` }
        });
        label.style.marginLeft = "10px";
        label.style.cursor = "pointer";
      });
      const skipRow = form.createEl("div", { cls: "move-by-tag-rule-option" });
      skipRow.style.marginBottom = "10px";
      skipRow.style.display = "flex";
      skipRow.style.alignItems = "center";
      const skipRadio = skipRow.createEl("input", {
        type: "radio",
        attr: {
          name: "folder-option",
          id: "folder-option-skip",
          value: "skip"
        }
      });
      const skipLabel = skipRow.createEl("label", {
        text: "Skip this file",
        attr: { for: "folder-option-skip" }
      });
      skipLabel.style.marginLeft = "10px";
      skipLabel.style.cursor = "pointer";
      const submitButton = form.createEl("button", {
        text: "Continue",
        cls: "mod-cta",
        attr: {
          type: "button"
          // Explicitly set type to button to prevent form submission
        }
      });
      submitButton.addEventListener("click", () => {
        const selectedRadio = form.querySelector('input[name="folder-option"]:checked');
        if (selectedRadio) {
          modal.close();
          if (selectedRadio.value === "skip") {
            resolve(null);
          } else {
            resolve(selectedRadio.value);
          }
        } else {
          if (matches.length > 0) {
            modal.close();
            resolve(matches[0].mapping.folder);
          } else {
            modal.close();
            resolve(null);
          }
        }
      });
      modal.onClose = () => {
        const suggestionsContainer = document.getElementById("folder-suggestions");
        if (suggestionsContainer) {
          suggestionsContainer.remove();
        }
      };
      modal.open();
    });
  }
};

// src/ui/InfoDialog.ts
var InfoDialog = class extends import_obsidian3.Modal {
  constructor(app, content, file, settings, logger) {
    super(app);
    this.fileMovementService = null;
    this.content = content;
    this.file = file || null;
    if (file && settings && logger) {
      const fileUtils = new FileUtils(app);
      const tagMappingService = new TagMappingService();
      this.fileMovementService = new FileMovementService(
        app,
        settings,
        fileUtils,
        tagMappingService,
        logger
      );
    }
  }
  onOpen() {
    const { contentEl } = this;
    this.titleEl.setText("File Information");
    const container = contentEl.createDiv({ cls: "file-info-container" });
    container.style.padding = "10px";
    container.style.maxWidth = "600px";
    const sections = this.parseContent(this.content);
    if (sections.header) {
      const headerEl = container.createDiv({ cls: "file-info-header" });
      headerEl.style.marginBottom = "15px";
      headerEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      headerEl.style.paddingBottom = "10px";
      if (sections.fileName) {
        const fileNameEl = headerEl.createDiv({ cls: "file-info-name" });
        fileNameEl.style.fontSize = "1.2em";
        fileNameEl.style.fontWeight = "bold";
        fileNameEl.style.display = "flex";
        fileNameEl.style.alignItems = "center";
        fileNameEl.style.marginBottom = "5px";
        const iconEl = fileNameEl.createSpan({ cls: "file-info-icon" });
        iconEl.style.marginRight = "8px";
        iconEl.innerHTML = `<svg viewBox="0 0 100 100" width="20" height="20" class="document"><path fill="currentColor" stroke="currentColor" d="M14,4v92h72V29.2l-0.6-0.6l-24-24L60.8,4L14,4z M18,8h40v24h24v60H18V8z M62,10.9L79.1,28H62V10.9z"></path></svg>`;
        fileNameEl.createSpan({ text: sections.fileName });
      }
      if (sections.filePath) {
        const pathEl = headerEl.createDiv({ cls: "file-info-path" });
        pathEl.style.fontSize = "0.9em";
        pathEl.style.color = "var(--text-muted)";
        pathEl.style.marginBottom = "5px";
        pathEl.createSpan({ text: "Path: " });
        pathEl.createSpan({ text: sections.filePath });
      }
    }
    if (sections.tags) {
      const tagsSection = container.createDiv({ cls: "file-info-tags-section" });
      tagsSection.style.marginBottom = "15px";
      const tagsHeader = tagsSection.createEl("h4", { text: "Tags" });
      tagsHeader.style.marginBottom = "8px";
      tagsHeader.style.marginTop = "0";
      const tagsContainer = tagsSection.createDiv({ cls: "file-info-tags" });
      tagsContainer.style.display = "flex";
      tagsContainer.style.flexWrap = "wrap";
      tagsContainer.style.gap = "5px";
      if (sections.tagsList && sections.tagsList.length > 0) {
        sections.tagsList.forEach((tag) => {
          const tagEl = tagsContainer.createSpan({ cls: "file-info-tag", text: tag });
          tagEl.style.backgroundColor = "var(--interactive-accent)";
          tagEl.style.color = "var(--text-on-accent)";
          tagEl.style.padding = "2px 8px";
          tagEl.style.borderRadius = "4px";
          tagEl.style.fontSize = "0.85em";
        });
      } else {
        tagsContainer.createSpan({
          text: "No tags found",
          cls: "file-info-no-tags"
        }).style.color = "var(--text-muted)";
      }
    }
    if (sections.matchingFolders) {
      const foldersSection = container.createDiv({ cls: "file-info-folders-section" });
      const foldersHeader = foldersSection.createEl("h4", { text: "Matching Folders" });
      foldersHeader.style.marginBottom = "8px";
      foldersHeader.style.marginTop = "0";
      if (sections.foldersList && sections.foldersList.length > 0) {
        const foldersList = foldersSection.createEl("ul");
        foldersList.style.paddingLeft = "20px";
        foldersList.style.margin = "0";
        sections.foldersList.forEach((folder) => {
          const folderItem = foldersList.createEl("li");
          folderItem.style.marginBottom = "5px";
          const match = folder.match(/^- (.*) \(tags: (.*)\)$/);
          if (match) {
            const folderPath = match[1];
            const folderTags = match[2];
            const folderPathEl = folderItem.createSpan();
            folderPathEl.style.display = "flex";
            folderPathEl.style.alignItems = "center";
            const iconEl = folderPathEl.createSpan({ cls: "folder-info-icon" });
            iconEl.style.marginRight = "5px";
            iconEl.innerHTML = `<svg viewBox="0 0 100 100" width="16" height="16" class="folder"><path fill="currentColor" stroke="currentColor" d="M10,20v60h80V30H50l-10-10H10z M15,25h22.5l7.5,7.5H85v42.5H15V25z"></path></svg>`;
            folderPathEl.createSpan({ text: folderPath });
            const tagsEl = folderItem.createDiv();
            tagsEl.style.fontSize = "0.85em";
            tagsEl.style.color = "var(--text-muted)";
            tagsEl.style.marginLeft = "21px";
            tagsEl.createSpan({ text: `Tags: ${folderTags}` });
          } else {
            folderItem.setText(folder);
          }
        });
      } else {
        foldersSection.createDiv({
          text: "No matching folders found",
          cls: "file-info-no-folders"
        }).style.color = "var(--text-muted)";
      }
    }
    const buttonContainer = container.createDiv({ cls: "file-info-buttons" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    const closeButton = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-warning"
    });
    if (this.file && this.fileMovementService && sections.foldersList && sections.foldersList.length > 0) {
      const moveButton = buttonContainer.createEl("button", {
        text: "Move File",
        cls: "mod-cta"
      });
      moveButton.style.marginLeft = "10px";
      moveButton.addEventListener("click", async () => {
        var _a;
        this.close();
        await ((_a = this.fileMovementService) == null ? void 0 : _a.moveFile(this.file));
      });
    }
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Parse the content string into structured sections
   */
  parseContent(content) {
    const result = {
      header: false,
      tags: false,
      matchingFolders: false
    };
    const lines = content.split("\n");
    let currentSection = "";
    for (const line of lines) {
      if (line.startsWith("File: ")) {
        result.header = true;
        result.fileName = line.substring(6);
        currentSection = "header";
      } else if (line.startsWith("Path: ")) {
        result.header = true;
        result.filePath = line.substring(6);
        currentSection = "header";
      } else if (line.startsWith("Tags: ")) {
        result.tags = true;
        const tagsText = line.substring(6);
        result.tagsList = tagsText === "None" ? [] : tagsText.split(", ");
        currentSection = "tags";
      } else if (line === "Matching Folders:") {
        result.matchingFolders = true;
        result.foldersList = [];
        currentSection = "folders";
      } else if (currentSection === "folders" && line.trim() !== "") {
        if (!result.foldersList)
          result.foldersList = [];
        result.foldersList.push(line);
      }
    }
    return result;
  }
};

// src/ui/MoveOptionsModal.ts
var import_obsidian4 = require("obsidian");
var MoveOptionsModal = class extends import_obsidian4.Modal {
  constructor(app, settings, logger) {
    super(app);
    this.settings = settings;
    this.logger = logger;
    this.activeFile = this.app.workspace.getActiveFile();
    const fileUtils = new FileUtils(this.app);
    const tagMappingService = new TagMappingService();
    this.fileMovementService = new FileMovementService(
      this.app,
      this.settings,
      fileUtils,
      tagMappingService,
      this.logger
    );
  }
  onOpen() {
    const { contentEl } = this;
    this.titleEl.setText("Move by Tag Options");
    const container = contentEl.createDiv({ cls: "move-options-container" });
    container.style.padding = "20px";
    container.style.maxWidth = "500px";
    const description = container.createEl("p", {
      text: "Choose how you want to move files based on tags:",
      cls: "move-options-description"
    });
    description.style.marginBottom = "20px";
    description.style.color = "var(--text-normal)";
    const buttonContainer = container.createDiv({ cls: "move-options-buttons" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.flexDirection = "column";
    buttonContainer.style.gap = "10px";
    this.createOptionButton(
      buttonContainer,
      "Move Current File",
      "Move only the currently active file based on its tags",
      async () => {
        if (this.activeFile) {
          this.close();
          await this.fileMovementService.moveFile(this.activeFile);
        }
      },
      !this.activeFile
      // Disabled if no active file
    );
    this.createOptionButton(
      buttonContainer,
      "Move Files in Current Folder",
      "Move all files in the same folder as the active file",
      async () => {
        if (this.activeFile) {
          this.close();
          await this.fileMovementService.moveFiles("current_folder" /* CURRENT_FOLDER */, this.activeFile);
        }
      },
      !this.activeFile
      // Disabled if no active file
    );
    this.createOptionButton(
      buttonContainer,
      "Move Files in All Folders",
      "Move files across the vault based, respecting Excluded and Specific folder settings",
      async () => {
        this.close();
        await this.fileMovementService.moveFiles("all_folders" /* ALL_FOLDERS */);
      }
    );
    const cancelButtonContainer = container.createDiv();
    cancelButtonContainer.style.marginTop = "20px";
    cancelButtonContainer.style.display = "flex";
    cancelButtonContainer.style.justifyContent = "flex-end";
    const cancelButton = cancelButtonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-warning"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  /**
   * Create an option button with description
   */
  createOptionButton(container, label, description, onClick, disabled = false) {
    const buttonWrapper = container.createDiv({ cls: "move-option-button-wrapper" });
    buttonWrapper.style.display = "flex";
    buttonWrapper.style.flexDirection = "column";
    buttonWrapper.style.border = "1px solid var(--background-modifier-border)";
    buttonWrapper.style.borderRadius = "4px";
    buttonWrapper.style.padding = "10px";
    if (!disabled) {
      buttonWrapper.style.cursor = "pointer";
      buttonWrapper.style.transition = "background-color 0.2s ease";
      buttonWrapper.addEventListener("mouseover", () => {
        buttonWrapper.style.backgroundColor = "var(--background-secondary-alt)";
      });
      buttonWrapper.addEventListener("mouseout", () => {
        buttonWrapper.style.backgroundColor = "";
      });
      buttonWrapper.addEventListener("click", onClick);
    } else {
      buttonWrapper.style.opacity = "0.5";
      buttonWrapper.style.cursor = "not-allowed";
    }
    const labelEl = buttonWrapper.createEl("div", {
      text: label,
      cls: "move-option-label"
    });
    labelEl.style.fontWeight = "bold";
    labelEl.style.marginBottom = "5px";
    const descriptionEl = buttonWrapper.createEl("div", {
      text: description,
      cls: "move-option-description"
    });
    descriptionEl.style.fontSize = "0.85em";
    descriptionEl.style.color = "var(--text-muted)";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/CommandManager.ts
var CommandManager = class {
  constructor(plugin, app, settings, fileUtils, logger) {
    this.plugin = plugin;
    this.app = app;
    this.settings = settings;
    this.fileUtils = fileUtils;
    this.logger = logger;
  }
  /**
   * Register all commands
   */
  registerCommands() {
    this.registerMoveByTagCommand();
    this.registerShowFileInfoCommand();
    this.registerMoveInCurrentFolderCommand();
    this.registerMoveOptionsCommand();
  }
  /**
   * Register the Move by Tag command
   */
  registerMoveByTagCommand() {
    this.plugin.addCommand({
      id: "move-by-tag",
      name: "Move by Tag (All Folders)",
      callback: async () => {
        const fileMovementService = new FileMovementService(
          this.app,
          this.settings,
          this.fileUtils,
          new TagMappingService(),
          this.logger
        );
        await fileMovementService.moveFiles("all_folders" /* ALL_FOLDERS */);
      }
    });
  }
  /**
   * Register the Move in Current Folder command
   */
  registerMoveInCurrentFolderCommand() {
    this.plugin.addCommand({
      id: "move-in-current-folder",
      name: "Move by Tag (Current Folder)",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          if (!checking) {
            this.moveFilesInCurrentFolder(activeFile);
          }
          return true;
        }
        return false;
      }
    });
  }
  /**
   * Move files in the current folder
   */
  async moveFilesInCurrentFolder(activeFile) {
    const fileMovementService = new FileMovementService(
      this.app,
      this.settings,
      this.fileUtils,
      new TagMappingService(),
      this.logger
    );
    await fileMovementService.moveFiles("current_folder" /* CURRENT_FOLDER */, activeFile);
  }
  /**
   * Register the Show File Info command
   */
  registerShowFileInfoCommand() {
    this.plugin.addCommand({
      id: "show-file-info",
      name: "Show File Info",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          if (!checking) {
            this.showFileInfo(activeFile);
          }
          return true;
        }
        return false;
      }
    });
  }
  /**
   * Show file information
   */
  async showFileInfo(file) {
    const content = await this.app.vault.read(file);
    this.showFileInfoDialog(file, content);
  }
  /**
   * Show file information dialog
   */
  showFileInfoDialog(file, content) {
    const fileName = file.name;
    const filePath = file.path;
    const tags = this.fileUtils.extractTags(content);
    let infoText = `File: ${fileName}
Path: ${filePath}

Tags: ${tags.map((t) => "#" + t).join(", ") || "None"}

`;
    if (tags.length > 0) {
      infoText += "Matching Folders:\n";
      const matches = this.settings.tagMappings.filter((mapping) => {
        return mapping.tags.every(
          (tag) => tags.some(
            (fileTag) => fileTag.toLowerCase() === tag.toLowerCase() || fileTag.toLowerCase() === tag.toLowerCase() + "s" || fileTag.toLowerCase().slice(0, -1) === tag.toLowerCase()
          )
        );
      });
      if (matches.length > 0) {
        matches.forEach((mapping) => {
          infoText += `- ${mapping.folder} (tags: ${mapping.tags.map((t) => "#" + t).join(" + ")})
`;
        });
      } else {
        infoText += "- No matching folders found\n";
      }
    }
    new InfoDialog(this.app, infoText, file, this.settings, this.logger).open();
  }
  /**
   * Register the Move Options command
   */
  registerMoveOptionsCommand() {
    this.plugin.addCommand({
      id: "move-options",
      name: "Show Move Options",
      callback: () => {
        new MoveOptionsModal(this.app, this.settings, this.logger).open();
      }
    });
  }
};

// src/main.ts
var MoveByTag = class extends import_obsidian5.Plugin {
  log(message) {
    if (this.settings.enableLogging) {
      console.log(`[Move by Tag] ${message}`);
    }
  }
  async onload() {
    await this.loadSettings();
    this.fileUtils = new FileUtils(this.app);
    this.commandManager = new CommandManager(
      this,
      this.app,
      this.settings,
      this.fileUtils,
      this.log.bind(this)
    );
    this.commandManager.registerCommands();
    this.addSettingTab(new MoveByTagSettingTab(
      this.app,
      this,
      this.settings,
      this.saveSettings.bind(this)
    ));
    console.log("Move by Tag Plugin loaded");
  }
  async onunload() {
    console.log("Move by Tag Plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings.tagMappings.forEach((mapping) => {
      if (!mapping.id) {
        mapping.id = Date.now().toString(36) + Math.random().toString(36).substr(2);
      }
    });
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
